### Пример вызова приватного метода класса извне

```c++
class Foo {
	void foo() {
		std::cout << "Call private method foo!" << std::endl;
	}
};

// Объявляем функцию заранее
void call_foo(Foo& obj);

template<typename Class, auto Method>
struct AccessPrivate {
	friend void call_foo(Class& obj) {
		(obj.*Method)(); // Вызываем приватный метод
	}
};

// Явная специализация шаблона
template struct AccessPrivate<Foo, &Foo::foo>;

int main() {
	Foo obj;
	call_foo(obj);
	return 0;
}
```


### Пример доступа к приватному члену класса извне

```c++
class Foo {
	int m_foo{1024};
};

  

// Объявляем функцию заранее
int& get_private_member(Foo& obj);

template<typename Class, auto MemberPtr>
struct AccessPrivateMember {
	friend int& get_private_member(Foo& obj) {
		return obj.*MemberPtr;
	}
};

// Явная специализация шаблона
template struct AccessPrivateMember<Foo, &Foo::m_foo>;

int main() {
	Foo obj;
	int& m_foo = get_private_member(obj);
	assert(m_foo == 1024);
	
	return 0;
}
```

Этот трюк  основан на двух ключевых особенностях C++:

### 1. Явная специализация позволяет упоминать приватные члены и методы
* ***Суть**:  
	При явной специализации шаблона (explicit template specialization) стандарт C++ разрешает указывать приватные члены класса, даже если специализация делается вне класса.
	
	**Стандарт C++**:  
	Согласно [temp.explicit]/12:  
	*"Имя в явном инстанцировании или специализации может быть приватным членом класса."*

**Пример**:  
```cpp
// Легально, несмотря на приватность foo()
template struct AccessPrivate<Foo, &Foo::foo>;  
```

### 2. Friend-функция получает доступ
**Суть**:  
Функция, объявленная как `friend` внутри шаблонного класса, получает доступ к приватным членам того класса, для которого специализируется шаблон.

**Механика**:  
```cpp
template<typename Class, auto Method>
struct AccessPrivate {
	// friend получает доступ к Class
    friend void call_foo(Class& obj) {
        (obj.*Method)();  // Вызываем приватный метод
    }
};
```

---

### Как это работает вместе?
1. **Шаг 1**: Специализация шаблона "легализует" упоминание `&Foo::foo`  
   ```cpp
   template struct AccessPrivate<Foo, &Foo::foo>;
   ```

2. **Шаг 2**: Friend-функция внутри специализации получает право доступа  
   ```cpp
   // Для Foo генерируется:
   friend void call_foo(Foo& obj) {
       (obj.*&Foo::foo)();  // Теперь можно вызывать приватный метод
   }
   ```

---

### почему компилятор считает `friend void call_foo(Class& obj)` из шаблонного класса реализацией для глобальной `void call_foo(Foo& obj)`?

#### 1. Ключевое правило: `friend`-функции не являются методами класса

Когда вы объявляете `friend`-функцию **внутри** класса (или шаблона класса):

1. Она **не становится методом** этого класса
2. Она существует **в окружающем namespace** (глобальном или другом, где определён класс)
3. У неё **нет скрытого параметра `this`**

Пример:
```c++
class Foo {
    friend void bar(Foo&);  // bar - не метод Foo!
};
```

Функция `bar()` — это обычная свободная функция, а не метод.

---

### 2. Что происходит в вашем случае

#### Шаг 1: Объявление глобальной функции

```c++
void call_foo(Foo& obj);  // Обычная декларация
```

#### Шаг 2: Шаблон с `friend`-функцией

```c++
template<typename Class, auto Method>
struct AccessPrivate {
    friend void call_foo(Class& obj) {  // Это НЕ метод класса!
        (obj.*Method)();
    }
};
```

- `call_foo` здесь — это **дружественная функция**, а не метод `AccessPrivate`
- Она существует в том же namespace, где определён `AccessPrivate`

#### Шаг 3: Специализация

```c++
template struct AccessPrivate<Foo, &Foo::foo>;
```

Генерирует:

```c++
// Неявно создаётся:
friend void call_foo(Foo& obj) {
    (obj.*&Foo::foo)();
}
```

Эта функция:

1. Находится в **глобальном namespace** (как и исходное объявление)
2. Имеет **точно такую же сигнатуру** (`void(Foo&)`)
3. **Не является методом** `AccessPrivate<Foo, &Foo::foo>`

---

### 3. Почему компилятор считает их эквивалентными

1. **Идентичные сигнатуры**:
    
    - Объявление: `void call_foo(Foo&)`
        
    - Определение: `void call_foo(Foo&)`
        
2. **Правила для `friend`-функций**:
    
    - Если `friend`-функция определена внутри класса, она ведёт себя как обычная функция в окружающем namespace
        
    - Её можно считать "анонимно объявленной" в namespace
        
3. **Механизм линковки**:
    
    - На этапе компиляции: обе сущности имеют одинаковое манглированное имя (например, `_Z8call_fooR3Foo`)
        
    - Линковщик видит, что реализация соответствует объявлению
        

---

### 5. Аналогия с обычным классом

Рассмотрим нешаблонный случай:
```c++
// Обьявление функции
void foo();

struct Foo {
		// Определение внутри класса
		friend void foo() { std::cout << "Foo::foo()" << std::endl; } 
};

int main() {
	foo(); // Foo::foo()
	return 0;
}
```

Здесь `foo()`:

1. Реально существует в глобальном namespace
    
2. Не является методом `Foo`
    
3. Может быть вызвана как обычная функция
---

### 6. Важные нюансы

*  **Порядок объявлений**:
    
    - Предварительное объявление обязательно, чтобы `call_foo` была видима до специализации
        
* ***Перегрузки**:
    
    - Можно иметь несколько `friend`-функций с разными параметрами
        
- **Пространства имён**:
    
    - Если `AccessPrivate` определён в namespace, `friend`-функция тоже будет в этом namespace:
```c++
namespace ns {
template<typename...> struct AccessPrivate {
	friend void call_foo(Foo&);  // Будет в ns::
};
}
```
- **Перегрузки**:
    
    - Можно иметь несколько `friend`-функций с разными параметрами
---

### Вывод

Компилятор корректно связывает объявление и определение, потому что:

1. `friend void call_foo(Class&)` — это **не метод класса**, а обычная функция в глобальном namespace
    
2. Её сигнатура **полностью совпадает** с предварительным объявлением
    
3. Правила C++ явно разрешают определять `friend`-функции внутри классов
    

Это не "метод шаблонного класса", а **обычная функция**, которая просто определена внутри шаблона для удобства доступа к приватным членам.

### Важные нюансы
1. **Только для явной специализации**  
   Не сработает с частичной специализацией или неявным инстанцированием.

2. **Требует предварительного объявления**  
   Чтобы `call_foo` была видна в точке вызова:
   ```cpp
   void call_foo(Foo& obj);  // Forward declaration
   ```

3. **Не работает для static-членов**  
   Для них нужен другой подход (через специализацию шаблонных переменных).

---

### Почему это не UB?
- **Соответствует стандарту**: Явная специализация + friend — легальные механизмы.  
- **Не нарушает ODR**: Каждая специализация создаёт уникальную сущность.  

Но! Это **нарушает инкапсуляцию**, поэтому должно использоваться осознанно (например, для unit-тестов).

### Вывод

Компилятор корректно связывает объявление и определение, потому что:

1. `friend void call_foo(Class&)` — это **не метод класса**, а обычная функция в глобальном namespace
    
2. Её сигнатура **полностью совпадает** с предварительным объявлением
    
3. Правила C++ явно разрешают определять `friend`-функции внутри классов
    

Это не "метод шаблонного класса", а **обычная функция**, которая просто определена внутри шаблона для удобства доступа к приватным членам.