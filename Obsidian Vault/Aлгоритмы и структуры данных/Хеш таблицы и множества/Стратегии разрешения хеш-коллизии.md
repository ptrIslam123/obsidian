В хеш-таблицах коллизии (ситуации, когда разные ключи имеют одинаковый хеш) неизбежны. Существует несколько основных стратегий их разрешения:

### 1. **Метод цепочек (Separate Chaining)**
   - **Суть**: Каждая ячейка таблицы содержит связный список (или другую структуру) элементов с одинаковым хешем.
   - **Как работает**:
     - При коллизии новый элемент добавляется в список соответствующей ячейки.
     - Поиск проходит по списку в ячейке.
   - **Плюсы**:
     - Простота реализации.
     - Таблица не переполняется (можно добавлять сколько угодно элементов).
   - **Минусы**:
     - Дополнительные расходы памяти на хранение указателей.
     - При большой коллизии поиск может деградировать до O(n).

### 2. **Открытая адресация (Open Addressing)**
   - **Суть**: Все элементы хранятся непосредственно в массиве хеш-таблицы. При коллизии ищется следующая свободная ячейка.
   - **Основные стратегии поиска места**:
     - **Линейное пробирование**: `h(k, i) = (h'(k) + i) % m`
       - Простое перемещение на следующую ячейку.
       - Проблема: кластеризация (образуются длинные последовательности занятых ячеек).
     - **Квадратичное пробирование**: `h(k, i) = (h'(k) + c₁i + c₂i²) % m`
       - Уменьшает кластеризацию, но может не охватить все ячейки.
     - **Двойное хеширование**: `h(k, i) = (h₁(k) + i*h₂(k)) % m`
       - Используется вторая хеш-функция для шага.
       - Наиболее равномерное распределение.
   - **Плюсы**:
     - Не нужны дополнительные структуры данных.
     - Лучшая локальность кэша (все данные в одном массиве).
   - **Минусы**:
     - Максимальный размер ограничен размером таблицы.
     - При высокой заполненности производительность падает.

### 3. **Robin Hood Hashing** (Улучшенная открытая адресация)
   - **Суть**: При вставке элемента, если он оказывается дальше от "идеальной" позиции, чем уже находящийся там элемент, они меняются местами.
   - **Плюсы**:
     - Более равномерное распределение.
     - Уменьшается среднее время поиска.
   - **Минусы**:
     - Сложнее реализация.
     - Дорогая вставка.

### 4. **Cuckoo Hashing**
   - **Суть**: Используется 2 (или более) хеш-функции и соответствующие таблицы.
     - Элемент помещается в одну из возможных ячеек.
     - Если ячейка занята, старый элемент "вытесняется" в свою альтернативную позицию.
   - **Плюсы**:
     - Гарантированное O(1) время поиска в худшем случае.
   - **Минусы**:
     - Сложная вставка (может потребовать рехеширования всей таблицы).
     - Нужно несколько хеш-функций.

### 5. **Hopscotch Hashing**
   - **Суть**: Комбинация открытой адресации и метода цепочек.
     - Каждая ячейка содержит информацию о соседних ячейках в пределах "окрестности".
     - Позволяет эффективно искать элементы вблизи их идеальной позиции.
   - **Плюсы**:
     - Хорошая производительность при высокой нагрузке.
   - **Минусы**:
     - Сложная реализация.

### Выбор стратегии зависит от:
- Ожидаемого количества элементов.
- Требований к скорости поиска/вставки.
- Доступной памяти.
- Важности времени выполнения в худшем случае.

**На практике**:
- Для общего назначения часто используют **метод цепочек** (как в Java `HashMap`) или **открытую адресацию** с двойным хешированием (как в Python `dict`).
- В высоконагруженных системах могут применяться **Robin Hood** или **Cuckoo hashing**.