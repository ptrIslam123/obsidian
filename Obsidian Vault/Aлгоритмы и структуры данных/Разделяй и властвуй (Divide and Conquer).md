## Разделяй и властвуй: подход к решению задач

**Разделяй и властвуй** (Divide and Conquer) - это мощный алгоритмический подход, который заключается в рекурсивном разбиении задачи на более мелкие подзадачи, решении этих подзадач и объединении их решений для получения ответа на исходную задачу.

**Основные этапы:**

1. **Разделение (Divide):** Исходная задача разбивается на несколько меньших подзадач, которые являются копиями исходной задачи, но имеют меньший размер.
2. **Властвование (Conquer):** Рекурсивно решаются подзадачи. Если подзадачи достаточно малы, чтобы их можно было решить напрямую, то это делается без рекурсии.
3. **Объединение (Combine):** Решения подзадач объединяются для получения решения исходной задачи.

**Преимущества:**

* **Эффективность:** Подход "разделяй и властвуй" часто позволяет решать задачи быстрее, чем другие подходы, особенно для задач, которые можно разбить на подзадачи с меньшим размером.
* **Простота:** Рекурсивная природа подхода делает его простым для понимания и реализации.
* **Масштабируемость:** Подход хорошо масштабируется для параллельных вычислений, так как подзадачи могут решаться независимо друг от друга.

**Недостатки:**

* **Накладные расходы:** Рекурсия и объединение решений подзадач могут привести к дополнительным накладным расходам по времени и памяти.
* **Сложность анализа:** Анализ сложности алгоритмов, основанных на подходе "разделяй и властвуй", может быть сложным.

**Примеры:**

* **Сортировка слиянием (Merge Sort):** 
    * **Разделение:** Массив разбивается на две половины.
    * **Властвование:** Каждая половина рекурсивно сортируется.
    * **Объединение:** Отсортированные половины сливаются в один отсортированный массив.
* **Быстрая сортировка (Quick Sort):**
    * **Разделение:** Выбирается опорный элемент, и массив разбивается на две части: элементы меньше опорного и элементы больше опорного.
    * **Властвование:** Каждая часть рекурсивно сортируется.
    * **Объединение:** Отсортированные части объединяются в один массив.
* **Бинарный поиск (Binary Search):**
    * **Разделение:** Массив разбивается на две половины.
    * **Властвование:** Проверяется, в какой половине находится искомый элемент, и поиск продолжается в этой половине.
    * **Объединение:** Поиск завершается, когда элемент найден или становится ясно, что его нет в массиве.


#####  Задача "Find in Mountain Array" (Найти в горном массиве). 
Это задача, которая требует поиска элемента в массиве, который имеет форму горы (сначала возрастает, затем убывает).

Дан массив `mountainArr`, который представляет собой горный массив. Необходимо найти индекс элемента `target` в этом массиве. Если элемент не найден, вернуть `-1`.

#### Примеры:
- Ввод: `mountainArr = [1, 2, 3, 4, 5, 3, 1], target = 3`
  - Вывод: `2`
  - Объяснение: Элемент `3` встречается на индексе `2`.

- Ввод: `mountainArr = [0, 1, 2, 4, 2, 1], target = 3`
  - Вывод: `-1`
  - Объяснение: Элемент `3` не найден в массиве.

Данную задачу легко решить, если найти пик горы. Допустим, что пик горы это `a[m]`, и например, `a[m] > target`. Значит, target находится в подмассиве `[a[0], a[1], ..., a[m - 1]]`. Так как это уже левая часть горы, то здесь все элементы идут строго по возрастанию, и можно продолжать поиск target, снова деля каждый вновь полученный подмассив пополам и сравнивая с центральным элементом этого подмассива, что занимает O(log n). Осталось только эффективно найти пик горы такого массива. 

Пик тоже можно найти подобным способом. Можно начать с центрального элемента, допустим `a[m]`. Тогда, если `a[m - 1] < a[m] и a[m + 1] < a[m]` - это пик. Если `a[m - 1] < a[m] < a[m + 1]` то пик находится в левой части подмассива, и повторяем эту процедуру, но уже для подмассива `a[m + 1 ... n - 1]`. Зеркально противоположное для делается для `a[m - 1] > a[m] > a[m + 1]`.

```python
def findInMountainArray(target, mountainArr):
    n = len(mountainArr)
    
    # Найти пик горы
    left, right = 0, n - 1
    while left < right:
        mid = (left + right) // 2
        if mountainArr[mid] < mountainArr[mid + 1]:
            left = mid + 1
        else:
            right = mid
    peak = left
    
    # Бинарный поиск в возрастающей части
    left, right = 0, peak
    while left <= right:
        mid = (left + right) // 2
        mid_val = mountainArr[mid]
        if mid_val == target:
            return mid
        elif mid_val < target:
            left = mid + 1
        else:
            right = mid - 1
    
    # Бинарный поиск в убывающей части
    left, right = peak, n - 1
    while left <= right:
        mid = (left + right) // 2
        mid_val = mountainArr[mid]
        if mid_val == target:
            return mid
        elif mid_val < target:
            right = mid - 1
        else:
            left = mid + 1
    
    return -1

arr = [1, 2, 3, 4, 5, 3, 1]
target = 3
print(findInMountainArray(target, arr)  # Вывод: 2
```


##### Median of Two Sorted Arrays)
Даны два отсортированных массива `nums1` и `nums2` одинаковой или разной длины. Необходимо найти медиану объединенного массива, состоящего из элементов `nums1` и `nums2`.
##### Определение медианы:

- Если объединенный массив имеет нечетное количество элементов, медиана — это средний элемент.
    
- Если объединенный массив имеет четное количество элементов, медиана — это среднее арифметическое двух средних элементов.
##### Основная идея:
1. **Разделение массивов:**
   - Представьте, что вы делите каждый из массивов `A` и `B` на две части. Ваша цель — найти такое разделение, чтобы сумма элементов в левой части (из обоих массивов) была равна сумме элементов в правой части.

2. **Условие для медианы:**
   - Для того чтобы разделение было правильным, должно выполняться следующее условие:
     - Максимальный элемент в левой части должен быть меньше или равен минимальному элементу в правой части.
     - Это условие можно записать как:
       - `max(A[partitionA-1], B[partitionB-1]) <= min(A[partitionA], B[partitionB])`

### Пошаговое объяснение:
1. **Определение индексов разделения:**
   - Пусть `partitionA` — это индекс, который делит массив `A` на две части.
   - Пусть `partitionB` — это индекс, который делит массив `B` на две части.
   - Важно, чтобы сумма элементов в левой части (из обоих массивов) была равна сумме элементов в правой части.

2. **Бинарный поиск:**
   - Используйте бинарный поиск для нахождения правильного разделения массивов `A` и `B`.
   - На каждом шаге бинарного поиска проверяйте условие для медианы.

### Пример:
Рассмотрим пример с массивами `A = [1, 3, 8, 9, 15]` и `B = [7, 11, 18, 19, 21, 25]`.

1. **Разделение массивов:**
   - Пусть `partitionA = 2` (делим `A` на `[1, 3]` и `[8, 9, 15]`).
   - Пусть `partitionB = 3` (делим `B` на `[7, 11, 18]` и `[19, 21, 25]`).

2. **Проверка условия:**
   - Левая часть: `[1, 3, 7, 11, 18]`
   - Правая часть: `[8, 9, 15, 19, 21, 25]`
   - Условие `max(3, 18) <= min(8, 19)` выполняется.

3. **Медиана:**
   - Длина объединенного массива `C` равна 11 (нечетное число).
   - Медиана — это средний элемент, который находится на индексе `k = 5`.
   - Медиана равна `11`
   
```python
def findMedianSortedArrays(A, B):
    if len(A) > len(B):
        A, B = B, A
    
    n, m = len(A), len(B)
    low, high = 0, n
    
    while low <= high:
        partitionA = (low + high) // 2
        partitionB = (n + m + 1) // 2 - partitionA
        
        maxLeftA = float('-inf') if partitionA == 0 else A[partitionA - 1]
        minRightA = float('inf') if partitionA == n else A[partitionA]
        
        maxLeftB = float('-inf') if partitionB == 0 else B[partitionB - 1]
        minRightB = float('inf') if partitionB == m else B[partitionB]
        
        if maxLeftA <= minRightB and maxLeftB <= minRightA:
            if (n + m) % 2 == 0:
                return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2
            else:
                return max(maxLeftA, maxLeftB)
        elif maxLeftA > minRightB:
            high = partitionA - 1
        else:
            low = partitionA + 1
    
    raise ValueError("Input arrays are not sorted.")

# Примеры использования
A = [1, 3, 8, 9, 15]
B = [7, 11, 18, 19, 21, 25]
print(findMedianSortedArrays(A, B))  # Вывод: 11

A = [1, 2]
B = [3, 4]
print(findMedianSortedArrays(A, B))  # Вывод: 2.5
```

Ключевой момент заключается в том, чтобы найти такое разделение массивов `A` и `B`, чтобы количество элементов в левой части было равно количеству элементов в правой части, и при этом выполнялось условие `max(A[partitionA-1], B[partitionB-1]) <= min(A[partitionA], B[partitionB])`. Это позволяет использовать бинарный поиск для эффективного нахождения медианы.

#### **Заключение:**
Подход "разделяй и властвуй" является мощным инструментом для решения широкого круга задач. Он позволяет разрабатывать эффективные и масштабируемые алгоритмы, но требует тщательного анализа и проектирования.