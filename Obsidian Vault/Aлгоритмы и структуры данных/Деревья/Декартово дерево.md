**Декартово дерево (Treap) — это комбинация(в прямом смыслк слова физическое сочетания двух структур данных) бинарного дерева поиска (BST) и кучи (heap), которая сочетает в себе свойства обоих структур данных. Каждый узел в декартовом дереве имеет два значения: ключ (key) и приоритет (priority). Ключи удовлетворяют свойствам бинарного дерева поиска, а приоритеты — свойствам кучи.**

**ВАЖНО:** В декартовом дереве (Treap) случайные приоритеты используются исключительно для поддержания сбалансированности структуры. Пользователь не взаимодействует напрямую с приоритетами и не должен знать их значения, так как они служат внутренним механизмом балансировки дерева. Случайные приоритеты обеспечивают эффективное распределение узлов по дереву, что в среднем приводит к логарифмической высоте дерева. Это гарантирует, что операции вставки, поиска и удаления будут выполняться за O(log n) в среднем.
### Свойства декартова дерева:

1. **Свойство бинарного дерева поиска**: Для каждого узла `x` все ключи в левом поддереве `x` меньше ключа `x`, а все ключи в правом поддереве `x` больше ключа `x`.

2. **Свойство кучи**: Для каждого узла `x` приоритет `x` больше или равен приоритетам всех его дочерних узлов (если рассматривать max-heap).    

### Основные операции и асимптотики:
1. **Вставка (Insert)**: Добавление нового элемента в дерево за O(log n) амортизированно.

2. **Поиск (Search)**: Поиск элемента в дереве по ключу за O(log n) амортизированно.

3. **Удаление (Delete)**: Удаление элемента из дерева по ключу за O(log n) амортизированно.

4. **(Приватный/внутренний метод) Split**: Разделение декартова дерева на два поддерева по заданному ключу за O(log n) амортизированно.

5. **(Приватный/внутренний метод) Merge**: Объединение двух декартовых деревьев в одно, предполагая, что все ключи в первом дереве меньше всех ключей во втором дереве за O(log n) амортизированно.

## Рассмотрит на примере этих данных как поэтапно строиться декартово дерево

![[photo_5318947513400679263_y.jpg]]

![[photo_5318947513400679262_y.jpg]]

![[photo_5318947513400679261_y.jpg]]

![[photo_5318947513400679260_y.jpg]]

![[photo_5318947513400679259_y.jpg]]

![[photo_5318947513400679258_y.jpg]]


```c++
// абстрактное определение узла декартового дерева
template<typename T>
struct Node {
	/* Ключ(Пользовательское значение) */
    T key;
    /* Приоритет узла, назначаемый рандомно как правило */
    int priority;
    
	/* Указатели на правое и левое соответственно поддеревя */
    Node* left;
    Node* right;

    Node(T k, int p) : key(k), priority(p), left(nullptr), right(nullptr) {}
};
```
## Split(k):
Метод `split` в декартовом дереве (Treap) предназначен для разделения дерева на два поддерева по заданному ключу. Этот метод является фундаментальным для многих операций с декартовым деревом, таких как вставка, удаление и другие. Вот подробное описание того, как работает метод `split`:

### Цель метода `split`:

Метод `split` разделяет декартово дерево на два поддерева:

- Левое поддерево содержит все узлы с ключами меньше или равными заданному ключу.
- Правое поддерево содержит все узлы с ключами больше заданного ключа.

### Алгоритм метода `split`:

По своей сути метод split должен дойти до того узла x.key == key. Этот узел будет токой/центром разделения поддерева/дерева на два поддерева. Вот и все.

1. **Базовый случай**: Если текущий узел (`node`) равен `nullptr`, то возвращаем пару `{nullptr, nullptr}`, так как нет узлов для разделения.

2. **Рекурсивный случай**:
    
    - Если заданный ключ (`key`) меньше ключа текущего узла (`node->key`), то рекурсивно вызываем `split` для левого поддерева (`node->left`).
        
        - Левое поддерево результата становится новым левым поддеревом текущего узла.
        
        - Правое поддерево результата становится новым правым поддеревом левого поддерева текущего узла.
        
        - Возвращаем пару `{левое поддерево результата, текущий узел}`.
        
    - Если заданный ключ (`key`) больше или равен ключу текущего узла (`node->key`), то рекурсивно вызываем `split` для правого поддерева (`node->right`).
        
        - Правое поддерево результата становится новым правым поддеревом текущего узла.
         
        - Левое поддерево результата становится новым левым поддеревом правого поддерева текущего узла.
        
        - Возвращаем пару `{текущий узел, правое поддерево результата}`.

```c++
// примерная реализация метода
// @param node - указател на корневой узел поддерева/дерева
// @param key - ключ разделения
// @return - пара корневых узлов, где все левое поддерево не превосходит
// или равное @key, а правое поддерево превосходит @key.
template<typename T>
std::pair<Node<T>*, Node<T>*> Treap<T>::split(Node<T>* node, T key) {
	if (!node) 
		return {nullptr, nullptr};

	if (key < node->key) {
		auto [left, right] = split(node->left, key);
		node->left = right;
		return {left, node};
	} else {
		auto [left, right] = split(node->right, key);
		node->right = left;
		return {node, right};
	}
}
```


## Алгоритм метода `Merge`

Метод `merge` объединяет два декартовых дерева `left` и `right` в одно дерево, предполагая, что все ключи в дереве `left` меньше всех ключей в дереве `right`. Объединение выполняется на основе приоритетов узлов: узел с большим приоритетом становится корнем, а оставшиеся деревья объединяются рекурсивно.

### Алгоритм метода `merge`:

1. **Базовый случай**: Если одно из деревьев (`left` или `right`) равно `nullptr`, возвращаем другое дерево, так как объединение с пустым деревом не требует дополнительных действий.
    
2. **Рекурсивный случай**:
    
    - Если приоритет корня левого дерева (`left->priority`) больше приоритета корня правого дерева (`right->priority`), то корень левого дерева становится корнем результирующего дерева.
        
        - Рекурсивно вызываем `merge` для правого поддерева левого дерева (`left->right`) и правого дерева (`right`).
         
        - Результат объединения становится новым правым поддеревом корня левого дерева.
        
        - Возвращаем корень левого дерева (`left`).
         
    - Если приоритет корня правого дерева (`right->priority`) больше или равен приоритету корня левого дерева (`left->priority`), то корень правого дерева становится корнем результирующего дерева.
        
        - Рекурсивно вызываем `merge` для левого дерева (`left`) и левого поддерева правого дерева (`right->left`).
        
        - Результат объединения становится новым левым поддеревом корня правого дерева.
        
        - Возвращаем корень правого дерева (`right`).


```c++
// примерная реализация метода

// ТРЕБОВАНИЕ: предполагается, что 
// все ключи в дереве `left` < ключей в дереве `right`

// @param left - левое поддерево/дерево
// @param right - правое поддерево/дерево
// @return Два обьедененных дерева в одно, удовлетворяющих
// требованиям декартового дерева
template<typename T>
Node<T>* Treap<T>::merge(Node<T>* left, Node<T>* right) {
    if (!left || !right) 
	    return left ? left : right;

    if (left->priority > right->priority) {
        left->right = merge(left->right, right);
        return left;
    } else {
        right->left = merge(left, right->left);
        return right;
    }
}
```

### Алгоритм вставки нового ключа (Insert):

1. **Разделение дерева**: Используйте метод `split` для разделения дерева по ключу нового элемента. Это создаст два поддерева:
    
    - Левое поддерево содержит все узлы с ключами меньше или равными заданному ключу.
        
    - Правое поддерево содержит все узлы с ключами больше заданного ключа.
        
2. **Создание нового узла**: Создайте новый узел с заданным ключом и случайным приоритетом.
    
3. **Объединение деревьев**: Используйте метод `merge` для объединения левого поддерева с новым узлом и затем результата с правым поддеревом.

```c++
template<typename T>
void Treap<T>::insert(Node<T>*& root, T key) {
    int priority = std::rand();
    auto [left, right] = split(root, key);
    Node<T>* newNode = new Node<T>(key, priority);
    root = merge(merge(left, newNode), right);
}
```

#### Алгоритм поиск (Search):
Абсолютно такой же как и в BST(бинорное дерево поиска)

#### алгоритм удаления ключа (Delete):

1. **Разделение дерева**: Используйте метод `split` для разделения дерева на три части:
    
    - Левое поддерево содержит все узлы с ключами меньше удаляемого ключа.
    
    - Удаляемый узел (или узлы, если есть дубликаты ключей).
     
    - Правое поддерево содержит все узлы с ключами больше удаляемого ключа.
    
2. **Объединение деревьев**: Используйте метод `merge` для объединения левого и правого поддеревьев, тем самым исключая удаляемый узел.

```c++
template<typename T>
void Treap<T>::remove(Node<T>*& root, T key) {
    auto [left, right] = split(root, key);
    auto [middle, right] = split(right, key + 1);
    delete middle;
    root = merge(left, right);
}
```