
### Сравнение с [[ДКА(Детерминированный конечный автомат)]]

Хотя **детерминированность** (наличие единственной последовательности состояний) — это ключевое различие между **DFA (Deterministic Finite Automaton)** и **NFA (Nondeterministic Finite Automaton)**, существуют и другие важные аспекты, которые стоит учитывать. Разберем все основные различия между DFA и NFA.


---

### **1. Детерминированный конечный автомат (DFA)**

#### **Свойства DFA:**
- Для каждого состояния `Si` и символа `c` из алфавита существует **ровно один переход** в другое состояние `Si+1`.
- Если символ $ c $ не удовлетворяет условиям перехода, автомат "застревает" или завершает работу без успеха.
- Автомат всегда следует строго **одному пути**, который определяется текущим состоянием и входным символом.
- **Нет ε-переходов** (переходов без чтения символа).

В случае **недетерминированного конечного автомата (NKA/NFA)** , если существует несколько возможных путей для обработки входной строки, автомат должен проверить **все возможные пути** , пока не найдёт хотя бы один успешный путь, который завершается в финальном состоянии. При этом не имеет значения, как именно происходит проверка этих путей — синхронно или асинхронно.

---

### **2. Недетерминированный конечный автомат (NFA)**

#### **Свойства NFA:**
- Из состояния $ S_i $ при чтении символа $ c $ можно перейти **в множество состояний** (не только в одно).
- Кроме того, возможны **ε-переходы** — переходы без чтения символа.
- Автомат может "развилиться" на несколько путей. Чтобы определить, принимает ли автомат строку, нужно проверить все возможные пути.
- Если хотя бы один путь приводит к финальному состоянию, строка считается принятой.

#### **Пример:**
 $$ \text{ Рассмотрим NFA с состояниями } \{q_0, q_1, q_2\} \text{ и алфавитом } \{a, b\}$$
  Переходы:
  -   $$ (q_0, a) \to \{q_1, q_2\} \text{  можно перейти в  } q_1  \text{ или } q_2 $$
  - $$ (q_1, b) \to q_2 $$
  - $$ (q_0, \varepsilon) \to q_1 \text{ (ε-переход) } $$

Если на вход подана строка `"ab"`, возможные пути могут быть следующими:
1. Путь 1:
   - Сначала по ε-переходу:  q0 -> q1
   - Чтение символа `a`: остаёмся в q1
   - Чтение символа `b`: q1 -> q2

2. Путь 2:
   - Чтение символа `a`: q0 -> q2
   - Чтение символа `b`: остаёмся в q2

В этом случае оба пути приводят к финальному состоянию q2, поэтому строка `"ab"` принимается.

---

### **3. Ключевые различия**

| **Характеристика**         | **DFA**                              | **NFA**                              |
|----------------------------|--------------------------------------|--------------------------------------|
| **Переходы**               | Ровно один переход для каждой пары `(состояние, символ)` | Множество переходов для одной пары `(состояние, символ)` |
| **ε-переходы**             | Отсутствуют                         | Присутствуют                         |
| **Количество путей**       | Всегда один путь                    | Может быть несколько путей           |
| **Принятие строки**        | Определяется единственным путём      | Определяется любым успешным путём    |
| **Эффективность реализации** | Более простая и быстрая             | Требует более сложной реализации     |

---

### **4. Почему NFA называется "недетерминированным"?**

Термин "недетерминированный" возникает из следующих причин:
1. **Множественные переходы**: Из одного состояния может быть несколько возможных переходов для одного и того же символа.
2. **ε-переходы**: Автомат может менять состояние без чтения входного символа.
3. **Неоднозначность пути**: Для одной и той же строки может существовать несколько различных путей через автомат.

---

### **1. Основное различие: детерминированность vs недетерминированность**

#### **DFA (Детерминированный конечный автомат):**
- Для каждого состояния и символа алфавита существует **ровно один переход**.
- Автомат всегда знает точно, куда перейти при чтении символа.
- **Единственная последовательность состояний** для каждой входной строки.

#### **NFA (Недетерминированный конечный автомат):**
- Для одного состояния и символа может быть **несколько переходов** или вообще нет переходов.
- Автомат может "выбирать" из нескольких возможных путей.
- Может использовать **ε-переходы** (переходы без чтения символа).
- **Множество возможных последовательностей состояний** для одной входной строки.

---

### **2. Различия в структуре и работе**

#### **2.1 Таблица переходов**
- **DFA**: Таблица переходов является полной и однозначной. Каждая клетка таблицы содержит ровно одно состояние, куда нужно перейти.
- **NFA**: Таблица переходов может содержать множественные состояния или пустые значения. Например, для пары `(состояние, символ)` может быть указано несколько целевых состояний.

#### **2.2 ε-переходы**
- **DFA**: Не допускает ε-переходов (переходов без чтения символа).
- **NFA**: Может иметь ε-переходы, что позволяет автомату переходить между состояниями без обработки входных данных.

---

### **3. Различия в поведении**

#### **3.1 Обработка входной строки**
- **DFA**: Проходит по единственному пути, шаг за шагом, читая каждый символ входной строки. Если на каком-то шаге не находится подходящего перехода, работа завершается неудачей.
- **NFA**: Может "развилиться" на несколько путей. Чтобы определить, принимает ли автомат строку, нужно проверить все возможные пути. Если хотя бы один путь приводит к финальному состоянию, строка считается принятой.

#### **3.2 Принятие/отклонение строки**
- **DFA**: Работает строго линейно. Если достигнуто финальное состояние после обработки всей строки, она принимается.
- **NFA**: Работает "параллельно" или "гипотетически". Если хотя бы один из возможных путей заканчивается в финальном состоянии, строка принимается.

---

### **4. Различия в мощности**

#### **Мощность языков**
- С точки зрения распознаваемых языков, **DFA и NFA эквивалентны**. Любую задачу, которую можно решить с помощью NFA, можно решить и с помощью DFA, и наоборот.
- Однако преобразование NFA в DFA может потребовать экспоненциального увеличения числа состояний (процесс называется **подстановкой состояний**).

---

### **5. Различия в эффективности**

#### **5.1 Реализация**
- **DFA**: Легче реализовать и более эффективен в работе, так как он всегда следует единственному пути. Его можно представить как простую таблицу переходов.
- **NFA**: Требует более сложной реализации, так как нужно учитывать множество возможных путей. Однако в теории NFA часто удобнее описывать, особенно для регулярных выражений.

#### **5.2 Память**
- **DFA**: Может требовать значительно больше состояний, чем соответствующий NFA, особенно для сложных задач.
- **NFA**: Занимает меньше места, но требует дополнительных вычислений для обработки всех возможных путей.

---

### **6. Преимущества и недостатки**

#### **DFA:**
- **Преимущества**:
  - Более прост в реализации.
  - Работает быстро и предсказуемо.
- **Недостатки**:
  - Может требовать большого количества состояний для сложных задач.

#### **NFA:**
- **Преимущества**:
  - Компактнее в описании.
  - Удобен для моделирования некоторых задач (например, регулярных выражений).
- **Недостатки**:
  - Требует более сложной реализации.
  - Может быть медленнее при работе.

---

### **7. Пример сравнения**

Рассмотрим автомат, который принимает строки, содержащие подстроку `"ab"`:

#### **DFA:**
```
Состояния: {q0, q1, q2}
Алфавит: {a, b}
Переходы:
(q0, a) → q1
(q1, b) → q2
(q2, a) → q1
(q2, b) → q2
Все остальные переходы остаются в том же состоянии.
Финальное состояние: q2
```

#### **NFA:**
```
Состояния: {q0, q1, q2}
Алфавит: {a, b}
Переходы:
(q0, a) → q1
(q1, b) → q2
(q2, a) → q1
(q2, b) → q2
(q0, ε) → q1  // ε-переход
Финальное состояние: q2
```

Здесь NFA использует ε-переход, чтобы сделать описание более компактным, тогда как DFA требует явного указания всех переходов.


### **Детерминация автомата**

Перевести автомат из ДКА в НКА легко. Нам просто ничего не нужно делать, т.к. ДКА это обобщенный случай НКА.  
Но что делать если мы хотим превести из НКА в ДКА. Этот процесс называется детерминацией автомата.

//! TODO


### **Алгоритм минимизации ДКА**

Любой ДКА имеет эквиалетный ему ДКА с минимальным числом состояний. Как его «сжать»? Заметим, что неразличимые вершины мы можем соединить в одну.

//! TODO

### **объединением автоматов через их регулярные представления**

### **2. Ваш случай: декомпозиция лексера**

Ваша задача — создать лексер, который может распознавать различные типы токенов (числа, строки, символы и т.д.). Для этого вы планируете:
1. Создать отдельные автоматы для каждого типа токенов (например, для чисел, строк, ключевых слов и т.д.).
2. Объединить эти автоматы в один общий автомат.

Этот процесс называется **объединением регулярных выражений** или **объединением автоматов через их регулярные представления**. Это немного отличается от "произведения автоматов", хотя конечный результат также является одним автоматом.

---

### **3. Как это работает?**

#### **Шаг 1: Определение автоматов для разных типов токенов**
Вы создаёте отдельные DFA для каждого типа токена:
- **Автомат для чисел**: Распознаёт числа, такие как `123`, `45.67` и т.д.
- **Автомат для строк**: Распознаёт слова или идентификаторы, такие как `hello`, `world` и т.д.
- **Автомат для символов**: Распознаёт специальные символы, такие как `+`, `-`, `*`, `/`.

Каждый такой автомат имеет своё множество состояний, алфавит, переходы и финальные состояния.

#### **Шаг 2: Объединение автоматов**
Чтобы объединить эти автоматы, вы используете следующие шаги:

1. **Объединение начальных состояний**:
   - Создайте новое начальное состояние, которое будет иметь ε-переходы (или прямые переходы) к начальным состояниям всех автоматов.

2. **Объединение переходов**:
   - Сохраните все переходы из исходных автоматов без изменений.
   - Если автоматы работают с одним и тем же алфавитом, объедините их алфавиты.

3. **Объединение финальных состояний**:
   - Все финальные состояния из исходных автоматов остаются финальными.
   - К каждому финальному состоянию можно добавить метку, чтобы определить, какой тип токена был распознан (например, "число", "строка", "символ").

#### **Пример структуры объединённого автомата**:
```
Новое начальное состояние → ε-переходы →
    |→ Автомат для чисел
    |→ Автомат для строк
    |→ Автомат для символов
```

#### **Шаг 3: Минимизация результирующего автомата**
После объединения автоматов может возникнуть много избыточных состояний. Чтобы упростить работу лексера, примените минимизацию DFA.

---

### **4. Почему это не "произведение автоматов"?**

Основное различие между вашим подходом и "произведением автоматов":
- **Цель**: Произведение автоматов используется для выполнения операций над языками (объединение, пересечение и т.д.), тогда как ваш подход направлен на создание одного большого автомата, способного распознавать несколько типов токенов.
- **Структура результата**: В случае произведения автоматов состояния нового автомата представляют собой пары состояний исходных автоматов ($ Q_{\text{new}} = Q_1 \times Q_2 $). В вашем случае новые состояния просто объединяют состояния всех автоматов без необходимости формировать пары.

---

### **5. Альтернативный подход: Использование NFA**

Если вам сложно сразу работать с DFA, вы можете:
1. Создать **NFA для каждого типа токена**.
2. Объединить эти NFA с помощью ε-переходов (например, создать общее начальное состояние с ε-переходами к начальным состояниям всех автоматов).
3. Преобразовать полученный NFA в эквивалентный DFA с помощью алгоритма подстановки состояний.

Этот подход часто проще реализовать, особенно если вы используете библиотеки или инструменты для работы с автоматами.

---

### **6. Пример реализации**

Предположим, мы хотим создать лексер, который распознаёт числа и идентификаторы.

#### **Автомат для чисел**:
- Состояния: $ \{q_0, q_1\} $
- Переходы:
  - $ (q_0, \text{цифра}) \to q_1 $
  - $ (q_1, \text{цифра}) \to q_1 $
- Финальное состояние: $ q_1 $

#### **Автомат для идентификаторов**:
- Состояния: $ \{p_0, p_1\} $
- Переходы:
  - $ (p_0, \text{буква}) \to p_1 $
  - $ (p_1, \text{буква или цифра}) \to p_1 $
- Финальное состояние: $ p_1 $

#### **Объединённый автомат**:
- Новое начальное состояние $ s_0 $ с ε-переходами:
  - $ (s_0, \varepsilon) \to q_0 $
  - $ (s_0, \varepsilon) \to p_0 $
- Все остальные переходы остаются без изменений.
- Финальные состояния: $ q_1 $ (число) и $ p_1 $ (идентификатор).
