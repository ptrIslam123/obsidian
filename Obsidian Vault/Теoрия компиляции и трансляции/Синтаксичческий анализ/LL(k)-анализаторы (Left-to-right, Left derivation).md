LL - top-down parsing. Синтаксическое дерево строиться от корня к листям, от терминалов к нетерминалам(токенам). Такой вид парсинга называется нисходящим.

LL-парсеры относятся к нисходящим (top-down) парсерам. В нисходящем парсинге синтаксическое дерево строится от корня к листьям, то есть от начального нетерминала к терминалам (токенам). Этот процесс можно представить как попытку "предсказать" структуру входной строки, начиная с самого верхнего уровня и постепенно спускаясь вниз.

### Основные характеристики нисходящего парсинга:

1. **Начало с корня**: Парсер начинает с начального нетерминала грамматики и пытается построить дерево разбора, применяя правила грамматики.
    
2. **Предсказание**: На каждом шаге парсер предсказывает, какое правило грамматики применить, основываясь на текущем нетерминале(lookahead символе).
    
3. **Строительство дерева**: Дерево разбора строится постепенно, от корня к листьям.
    
4. **Ограничения**: Нисходящие парсеры, такие как LL(1), имеют ограничения, такие как невозможность обработки левой рекурсии и неоднозначных грамматик без предварительной модификации.

### Основные шаги алгоритма LL(1) парсера

1. **Инициализация**:
    
    - Инициализируйте стек, поместив в него начальный символ грамматики и маркер конца строки (`$`).
        
    - Инициализируйте входную строку, добавив к ней маркер конца строки (`$`).
        
2. **Основной цикл**:
    
    - Пока стек не пуст:
        
        - Если верхний элемент стека — терминал, проверьте, совпадает ли он с текущим символом входной строки:
            
            - Если совпадает, удалите верхний элемент стека и перейдите к следующему символу входной строки.
                
            - Если не совпадает, возникла ошибка разбора.
                
        - Если верхний элемент стека — нетерминал, используйте таблицу разбора LL(1) для определения правила грамматики, которое нужно применить:
            
            - Если в таблице разбора есть правило для текущего нетерминала и lookahead символа, замените верхний элемент стека на правую часть правила (в обратном порядке).
                
            - Если в таблице разбора нет правила, возникла ошибка разбора.
                
3. **Завершение**:
    
    - Если стек пуст и входная строка полностью прочитана (достигнут маркер конца строки `$`), разбор успешно завершен.
        
    - Если стек пуст, но входная строка не прочитана до конца, или наоборот, возникла ошибка разбора.


### Основной принцип вычисления FIRST-множеств:  
  
1. **Если первый символ в правиле — терминал**:  
   - То этот терминал добавляется в **FIRST-множество** для данного нетерминала.  
  
2. **Если первый символ в правиле — нетерминал**:  
   - То мы рекурсивно вычисляем **FIRST-множество** для этого нетерминала и добавляем его в **FIRST-множество** текущего нетерминала.  
  
3. **Если правило может выводить пустую строку epsilon**:  
   - То epsilon добавляется в **FIRST-множество** данного нетерминала.  
  
### Пошаговый алгоритм вычисления FIRST-множеств:  
  
1. **Для каждого правила `A -> a`**:  
   - Если `a` начинается с терминала `t`, то добавляем `t` в **FIRST(A)**.  
   - Если `a` начинается с нетерминала `B`, то добавляем все элементы из **FIRST(B)** в **FIRST(A)**, кроме `epsilon`.  
   - Если `B` может выводить `epsilon` т.е. $$ \epsilon \in \text{FIRST}(B)$$, то продолжаем рассматривать следующие символы в правиле `a`.  
  
2. **Если все символы в правиле `a` могут выводить `epsilon`**:  
   - То добавляем `epsilon` в **FIRST(A)**.

### Рассмотрим как строиться таблица для множества FIRST

* Исходная грамматика 
```
S -> E
E -> T + E | T
T -> id
```
  
* **Шаг 1: Определение терминалов и нетерминалов**  
	- **Терминалы**: `id`, `+`  
	- **Нетерминалы**: `S`, `E`, `T`  
	  

* **Шаг 2: Вычисление FIRST-множеств **
  
1. Вычислим FIRST(T) 
	Правило для T:  
	  
	T -> id  
	- T выводит только терминал `id`.  
	- Поэтому:  FIRST(T) = { id }  
	  
	  

2. Вычислим FIRST(E)    
	Правила для E:  
	  
	E ->T + E | T  
	  
	- Первый символ в обеих альтернативах правила E -> T + E и E -> T — это нетерминал T.  
	- Мы уже знаем, что FIRST(T) = { id }.  
	- Поэтому:  FIRST(E) = FIRST(T) = { id }   
  
3. Вычислим FIRST(S)  
	Правило для S:  
	  
	S -> E  
	  
	- Первый символ в правиле S -> E — это нетерминал E  
	- Мы уже знаем, что FIRST(E) = { id }.  
	- Поэтому:  FIRST(S) = FIRST(E) = { id }  
	  
  
### Итоговые FIRST-множества:  
  
- FIRST(S) = { id }  
- FIRST(E) = { id }  
- FIRST(T) = { id }    
  
### Пояснение:  
  
1. **FIRST(T)**:  
   - T выводит только терминал `id`, поэтому FIRST(T) = { id }  
  
2. **FIRST(E)**:  
   - E выводит либо T + E, либо T  
   - В обоих случаях первый символ — это T, а FIRST(T) = { id }  
   - Поэтому FIRST(E) = { id }  
  
3. **FIRST(S)**:  
   - S выводит E, а FIRST(E) = { id }  
   - Поэтому FIRST(S) = { id }    
  
### Важно:  
  
- Если бы в грамматике были альтернативные правила, например, E  id | + , то FIRST(E) включал бы оба терминала: { id, + }  
- В данном случае все правила начинаются с T, и T выводит только `id`, поэтому все **FIRST-множества** содержат только `id`.  

### **Зачем нужен FIRST?**

**FIRST** — это множество символов, которые могут быть первыми в строке, полученной при применении какой-либо продукции (правила) грамматики. 

#### Пример:
Рассмотрим грамматику:
```
S -> cAd
A -> bc | a
```
И входная строка: `cad`.

- Когда парсер видит символ `c` в строке, он может применить правило `S -> cAd`.
- Далее, парсер видит символ `a`. Чтобы выбрать правило для нетерминала `A`, он должен знать, какие символы могут быть первыми в строке, полученной при применении правил для `A`.
  - Для `A -> bc`: первый символ — `b`.
  - Для `A -> a`: первый символ — `a`.
- Так как текущий символ — `a`, парсер выбирает правило `A -> a`.

**Вывод:** Зная **FIRST** для каждого нетерминала, парсер может принимать обоснованные решения о том, какое правило применить, основываясь на текущем символе входной строки.


### Основной принцип вычисления FOLLOW-множеств:  

**Множество FOLLOW(A)** содержит все терминальные символы, которые могут следовать за(после) нетерминалом **A** в процессе разбора грамматики.
Мы добавляем терминалы, которые **после A**, а не **перед A**.
### Правила для вычисления FOLLOW-множеств  
  
1. **Начальное правило**: Если **A** — стартовый нетерминал грамматики, то добавляем символ конца входной строки (обычно обозначается как `$`) в **FOLLOW(A)**.
    
2. **FOLLOW(A)** включает все терминалы, которые могут появиться **сразу после A** в процессе разбора грамматики.
    
3. Если в строке есть последовательность вида **... Ax ...**, где **x** — терминал, то **x** добавляется в **FOLLOW(A)**.
    
4. Если за **A** следует нетерминал **B**, то **FOLLOW(A)** включает терминалы из **FIRST(B)** , **но с оговоркой**:
	* Если **B** может быть пустой строкой (`ε`), то **FOLLOW(A)** также включает **FOLLOW(B)** (где `B` — нетерминал, в котором находится `A`).

### Рассмотрим как строиться таблица для множества FOLLOW

* Исходная грамматика 
```
S -> E
E -> T + E | T
T -> id
```

* Шаг 1: Определение стартового нетерминала  
  
- Стартовый нетерминал — S  
  
* Шаг 2: Вычисление FOLLOW-множеств  
  
1. Вычислим FOLLOW(S)  
  
- S — стартовый нетерминал.  
- Поэтому:  FOLLOW(S) = { $ }  
  
2. Вычислим FOLLOW(E)  
  
- Правило S ->E  
  - E находится в конце правила S -> E  
  - Поэтому добавляем все элементы из **FOLLOW(S)** в **FOLLOW(E)**: 
	  FOLLOW(E) = FOLLOW(S) = { $ }  
  
  
3. Вычислим FOLLOW(T)  
  
- Правило E -> T + E  
  - T находится в начале правила E -> T + E  
  - После T следует +, который является терминалом.  
  - Поэтому добавляем +  в **FOLLOW(T)**: 
	FOLLOW(T) = { + }
  
- Также T находится в конце правила E -> T  
  - Поэтому добавляем все элементы из **FOLLOW(E)** в **FOLLOW(T)**:  
	  FOLLOW(T) = FOLLOW(E) = { +, $ } 
  
---  
  
### Итоговые FOLLOW-множества:  
  
- FOLLOW(S) = { $ }  
- FOLLOW(E) = { $ }  
- FOLLOW(T) = { +, $ }    
  
### Пояснение:  
  
1. **FOLLOW(S)**:  
   - S — стартовый нетерминал, поэтому добавляем $.  
  
2. **FOLLOW(E)**:  
   - E находится в конце правила S -> E, поэтому добавляем $ из **FOLLOW(S)**.  
  
3. **FOLLOW(T)**:  
   - T находится в начале правила E -> T + E, после чего следует терминал +, поэтому добавляем +.  
   - T также находится в конце правила E -> T, поэтому добавляем $ из **FOLLOW(E)**  
  
### Важно:  
  
- Если в правилах есть нетерминалы, которые могут выводить \(\epsilon\), то мы учитываем это, добавляя \(\epsilon\) в **FIRST-множества** и продолжая рассматривать следующие символы в правиле.  
- Если нетерминал находится в конце правила, то мы добавляем все элементы из **FOLLOW** родительского нетерминала.

### **Зачем нужен FOLLOW?**

**FOLLOW** — это множество символов, которые могут следовать за данным нетерминалом в любой сентенциальной форме грамматики.

#### Пример:
Рассмотрим грамматику:
```
A -> aBb
B -> c | ε
```
И входная строка: `ab`.

- Парсер применяет правило `A -> aBb`, так как первый символ — `a`.
- Далее, он видит символ `b` и должен вывести нетерминал `B`.
  - Для `B` есть два правила: `B -> c` и `B -> ε` (пустая строка).
  - Первый символ для `B -> c` — `c`, но текущий символ — `b`.
  - Однако, если применить `B -> ε`, то `B` исчезнет, и парсер получит строку `ab`.
- Чтобы принять решение о применении `B -> ε`, парсер должен знать, что за `B` в правиле `A -> aBb` следует символ `b` (это **FOLLOW(B)**).
- Так как текущий символ — `b`, и он совпадает с **FOLLOW(B)**, парсер применяет `B -> ε`.

**Вывод:** **FOLLOW** помогает парсеру решить, когда можно применить правило, которое приводит к пустой строке (например, `ε`), основываясь на символе, следующем за данным нетерминалом.

---

### **Как образуются FIRST и FOLLOW?**

#### **FIRST:**
- Для терминалов: **FIRST(X)** — это сам символ `X`.
- Для нетерминалов: **FIRST(X)** — это множество всех терминалов, которые могут быть первыми в строке, полученной при применении правил для `X`.
  - Если правило `X -> Y1 Y2 ... Yn`, то **FIRST(X)** включает **FIRST(Y1)**.
  - Если `Y1` может быть пустой строкой (`ε`), то добавляется **FIRST(Y2)**, и так далее.

#### **FOLLOW:**
- Для стартового нетерминала: **FOLLOW(S)** включает `$` (конец строки).
- Для других нетерминалов:
  - Если есть правило `X -> αYβ`, то **FOLLOW(Y)** включает **FIRST(β)** (если `β` не может быть пустой строкой).
  - Если `β` может быть пустой строкой (`ε`), или если `Y` находится в конце правила, то **FOLLOW(Y)** включает **FOLLOW(X)**.




Таблица переходов (Parsing Table) строится на основе множеств **FIRST** и **FOLLOW** для грамматики. Эта таблица используется **LL(1) парсером** для выбора правил грамматики на основе текущего символа входной строки (lookahead). Давайте разберем, как это делается, на примере.

---

### **Шаги построения таблицы переходов**

1. **Вычислить FIRST и FOLLOW для всех нетерминалов грамматики.**
2. **Заполнить таблицу переходов** на основе правил грамматики и множеств **FIRST** и **FOLLOW**.

---

### **Пример грамматики**

Рассмотрим следующую грамматику:
```
S -> cAd
A -> bc | a
```

#### Шаг 1: Вычисление FIRST и FOLLOW

- **FIRST(S) = {c}** (поскольку `S -> cAd` начинается с `c`).
- **FIRST(A) = {b, a}** (поскольку `A -> bc` начинается с `b`, а `A -> a` начинается с `a`).
- **FOLLOW(S) = {$}** (поскольку `S` — стартовый нетерминал, конец строки).
- **FOLLOW(A) = {d}`** (поскольку после `A` в правиле `S -> cAd` следует `d`).

---

### **Шаг 2: Построение таблицы переходов**

Таблица переходов состоит из строк, соответствующих нетерминалам, и столбцов, соответствующих терминалам и символу конца строки (`$`).

#### Структура таблицы:

| Нетерминал | c   | a   | b   | d   | $   |
|------------|-----|-----|-----|-----|-----|
| S          |     |     |     |     |     |
| A          |     |     |     |     |     |

#### Заполнение таблицы:

1. **Для каждого правила грамматики `A -> α`:**
   - Если `α` не начинается с `ε` (пустой строки), то для каждого терминала `t` из **FIRST(α)**, добавляем правило `A -> α` в ячейку таблицы `[A, t]`.
   - Если `α` может начинаться с `ε` (т.е. **FIRST(α)** содержит `ε`), то для каждого терминала `t` из **FOLLOW(A)**, добавляем правило `A -> α` в ячейку таблицы `[A, t]`.

2. **Пример заполнения для нашей грамматики:**

   - **Правило `S -> cAd`:**
     - **FIRST(cAd) = {c}**.
     - Добавляем `S -> cAd` в ячейку `[S, c]`.

   - **Правило `A -> bc`:**
     - **FIRST(bc) = {b}**.
     - Добавляем `A -> bc` в ячейку `[A, b]`.

   - **Правило `A -> a`:**
     - **FIRST(a) = {a}**.
     - Добавляем `A -> a` в ячейку `[A, a]`.

#### Итоговая таблица:

| Нетерминал | c       | a       | b       | d   | $   |
|------------|---------|---------|---------|-----|-----|
| S          | S -> cAd |         |         |     |     |
| A          |         | A -> a  | A -> bc |     |     |

---

### **Как парсер использует таблицу переходов?**

Теперь, когда таблица построена, парсер может использовать её для разбора входной строки.

#### Пример: Разбор строки `cad`

1. **Инициализация:**
   - Входная строка: `cad$` (добавляем `$` для обозначения конца строки).
   - Стек: `[S, $]` (начинаем с начального нетерминала `S` и символа конца строки `$`).

2. **Шаг 1: Сравниваем верх стека с текущим символом входной строки.**
   - Верх стека: `S`
   - Текущий символ: `c`
   - Смотрим в таблице: `[S, c] = S -> cAd`.
   - Заменяем `S` на `cAd` в стеке: `[c, A, d, $]`.

3. **Шаг 2: Сравниваем верх стека с текущим символом входной строки.**
   - Верх стека: `c`
   - Текущий символ: `c`
   - Они совпадают, поэтому извлекаем `c` из стека и переходим к следующему символу входной строки: `[A, d, $]`.

4. **Шаг 3: Сравниваем верх стека с текущим символом входной строки.**
   - Верх стека: `A`
   - Текущий символ: `a`
   - Смотрим в таблице: `[A, a] = A -> a`.
   - Заменяем `A` на `a` в стеке: `[a, d, $]`.

5. **Шаг 4: Сравниваем верх стека с текущим символом входной строки.**
   - Верх стека: `a`
   - Текущий символ: `a`
   - Они совпадают, поэтому извлекаем `a` из стека и переходим к следующему символу входной строки: `[d, $]`.

6. **Шаг 5: Сравниваем верх стека с текущим символом входной строки.**
   - Верх стека: `d`
   - Текущий символ: `d`
   - Они совпадают, поэтому извлекаем `d` из стека и переходим к следующему символу входной строки: `[$]`.

7. **Шаг 6: Сравниваем верх стека с текущим символом входной строки.**
   - Верх стека: `$`
   - Текущий символ: `$`
   - Они совпадают, поэтому разбор завершен успешно.


Конечно! Давайте рассмотрим пример кода на Python, который строит дерево разбора на основе **LL(1)** парсера. Мы будем использовать таблицу переходов, построенную на основе **FIRST** и **FOLLOW**, и реализуем стековый алгоритм для разбора входной строки.

---

### **Пример грамматики**

Рассмотрим следующую грамматику:
```
S -> cAd
A -> bc | a
```

---

### **Шаг 1: Построение таблицы переходов**

Мы уже вычислили **FIRST** и **FOLLOW** для этой грамматики:
- **FIRST(S) = {c}**
- **FIRST(A) = {b, a}**
- **FOLLOW(S) = {$}**
- **FOLLOW(A) = {d}**

Таблица переходов:

| Нетерминал | c       | a       | b       | d   | $   |
|------------|---------|---------|---------|-----|-----|
| S          | S -> cAd |         |         |     |     |
| A          |         | A -> a  | A -> bc |     |     |

---

### **Шаг 2: Реализация LL(1) парсера**

Мы реализуем стековый алгоритм, который использует таблицу переходов для разбора входной строки.

#### Код на Python:

```python
class Parser:
    def __init__(self, grammar, parsing_table):
        self.grammar = grammar
        self.parsing_table = parsing_table
        self.stack = []
        self.input_string = ""
        self.index = 0

    def parse(self, input_string):
	    # Инициализация стека с начальным нетерминалом S и 
	    # символом конца строки $
        self.stack = ["$", "S"]  
        
        # Добавляем символ конца строки
        self.input_string = input_string + "$"  
        self.index = 0

        while len(self.stack) > 0:
            top = self.stack[-1]  # Верх стека
            # Текущий символ входной строки
            current_char = self.input_string[self.index]  

            if top == "$" and current_char == "$":
                print("Разбор успешно завершен!")
                return True
            elif top == current_char:
                print(f"Совпадение: {top}")
                self.stack.pop()  
                # Переходим к следующему символу входной строки
                self.index += 1  
            elif top in self.grammar:
                # Если верх стека - нетерминал, используем таблицу переходов
                if current_char in self.parsing_table[top]:
                    production = self.parsing_table[top][current_char]
                    print(f"Применено правило: {top} -> {production}")
                    self.stack.pop()  
                    # Добавляем правую часть правила в стек в обратном порядке
                    for symbol in reversed(production):
	                    # Игнорируем пустую строку
                        if symbol != "ε":  
                            self.stack.append(symbol)
                else:
                    print(f"Ошибка: Нет правила для {top} на входе {current_char}")
                    return False
            else:
                print(f"Ошибка: Несовпадение {top} и {current_char}")
                return False

        return False


# Грамматика
grammar = {
    "S": ["cAd"],
    "A": ["bc", "a"]
}

# Таблица переходов
parsing_table = {
    "S": {"c": "cAd"},
    "A": {"a": "a", "b": "bc"}
}

# Создаем парсер
parser = Parser(grammar, parsing_table)

# Входная строка
input_string = "cad"

# Запускаем разбор
parser.parse(input_string)
```

---

### **Объяснение кода**

1. **Класс `Parser`:**
   - Содержит метод `parse`, который выполняет разбор входной строки.
   - Использует стек для хранения символов грамматики.
   - Сравнивает верх стека с текущим символом входной строки.
   - Если верх стека — нетерминал, использует таблицу переходов для выбора правила.

2. **Таблица переходов:**
   - Хранится в виде словаря `parsing_table`, где ключи — нетерминалы, а значения — словари, сопоставляющие терминалы с правилами.

3. **Разбор строки:**
   - Начинается с инициализации стека с начальным нетерминалом `S` и символом конца строки `$`.
   - Последовательно сравнивает верх стека с текущим символом входной строки.
   - Если верх стека — нетерминал, заменяет его на правую часть правила из таблицы переходов.
   - Если верх стека — терминал, проверяет его совпадение с текущим символом входной строки.

4. **Пример вывода:**
   Для входной строки `cad` вывод будет следующим:
   ```
   Применено правило: S -> cAd
   Совпадение: c
   Применено правило: A -> a
   Совпадение: a
   Совпадение: d
   Разбор успешно завершен!
   ```

---

### **Итог**

- Код реализует **LL(1) парсер**, который использует таблицу переходов для разбора входной строки.
- Таблица переходов строится на основе **FIRST** и **FOLLOW**.
- Парсер строит дерево разбора, заменяя нетерминалы на правые части правил грамматики, пока не дойдет до конца строки.



---

# заметки

Для построения диаграммы переходов в алгоримте ll(k)  сначало требуется удалить из нее левую рекурсию, а затем выполнить левую факторизацию грамматики. Затем необходимо для каждого нетерминала A 

1) создать начальное и конечное состояние
2)  для каждой продукции A -> X1 X2 ... Xk создать путь из начального в конечное состояние с дугами, помеченными X1, X2, ..., Xk; Если A -> e, путь представляет собой ребро, помеченное e;
Переход для терминала(токена) означает, что этот переход будет выполнен, если этот токен будет очередным входным символом. Переход для нетерминала A представляет собой вызов процедуры для A.

В случае с ll(1) неоднозначность, использовать ли e-переход, может быть разрешена, елси считать e-переход выбором по умолчанию.

Алгоритм основан на слудеющей идее:

если очередной символ a находится в FIRST(a), выбирается продукия: A -> a; Единственная сложность возникает при a = e или в общем случае, когда a =>(*) e.
В этом случае мы снова должны выьрать A -> a, если текущий входной символ имеется в  FOLLOW(A) или если из входнога потока получен $(сивол конца входной строки), который при этом входит в FOLLOW(A)  



---
---

0(текущий токен) принадлежит как FIRST(D) так FIRST(D) обойх продукции, тогда смотрим какому множству FOLLOW(M) и FOLLOW(L) принадлежит t1(следующий токен после текущего) если и в этом случае пересечение, то считатся что ll(1) не может разрешить данную грамматику. Я прав?

Да, вы абсолютно правы. Давайте разберем вашу ситуацию более подробно и формализуем это для ясности.

### Проверка LL(1)-грамматики

Для того чтобы грамматика была **LL(1)**, необходимо выполнение следующих условий:

1. Для любой нетерминальной продукции $ A \to \alpha \ | \ \beta $ множества FIRST($\alpha$) и FIRST($\beta$) не должны пересекаться.
2. Если $\alpha$ может порождать пустую строку ($\epsilon$), то множество FOLLOW($A$) не должно пересекаться с FIRST($\beta$).

Теперь применим это к вашей ситуации:

#### Случай 1: Пересечение FIRST(D)
Если у вас есть две продукции:
$$
M \to D \ ...
$$
и
$$
L \to D \ ...
$$
где токен $0$ (текущий токен) принадлежит как FIRST($D$) в продукции $M$, так и в продукции $L$, то возникает проблема. Это означает, что на основе только текущего токена парсер не сможет однозначно определить, какую из двух производных выбрать.

#### Случай 2: Использование FOLLOW
Чтобы решить эту неоднозначность, нужно рассмотреть следующий токен после $D$ (обозначим его как $t_1$). Для этого мы проверяем, принадлежит ли $t_1$ множествам FOLLOW($M$) или FOLLOW($L$).

Если:
- $t_1 \in \text{FOLLOW}(M)$,
- $t_1 \in \text{FOLLOW}(L)$,

и при этом множества FOLLOW($M$) и FOLLOW($L$) пересекаются, то грамматика **не является LL(1)**, так как парсер не сможет однозначно выбрать между $M$ и $L$ даже с учетом следующего токена.

### Заключение
Вы абсолютно правы: если существует пересечение между FIRST($D$) для разных производств и также пересечение между соответствующими множествами FOLLOW, то грамматика **не может быть LL(1)**.

$$
\boxed{\text{Грамматика не является LL(1), если FIRST и FOLLOW создают конфликт выбора.}}
$$