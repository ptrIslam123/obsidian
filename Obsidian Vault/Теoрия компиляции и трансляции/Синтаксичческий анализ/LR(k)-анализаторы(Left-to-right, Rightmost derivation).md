Восходящий парсинг (bottom-up parsing) начинается с листьев (конкретных токенов) и постепенно строит дерево разбора до корня. Одним из наиболее известных алгоритмов восходящего парсинга является LR-парсер (Left-to-right, Rightmost derivation). LR-парсеры работают слева направо по входной строке и строят правосторонний вывод (rightmost derivation).

### Основные понятия

1. **Стековый автомат**: LR-парсер использует стек для хранения символов грамматики и состояний.
2. **Действия парсера**: Основные действия парсера — сдвиг (shift) и свертка (reduce).
   - **Сдвиг (Shift)**: Перенос следующего символа из входной строки в стек.
   - **Свертка (Reduce)**: Применение правила грамматики к символам в стеке, замена их на нетерминал.
3. **Таблица действий (Action Table)**: Таблица, которая определяет действия парсера в зависимости от текущего состояния и входного символа.
4. **Таблица переходов (Goto Table)**: Таблица, которая определяет следующее состояние парсера после свертки.

### Пример грамматики и построение LR(1) парсера

Рассмотрим пример грамматики для арифметических выражений:

```
E  -> E + T | T
T  -> T * F | F
F  -> ( E ) | id
```

#### Построение таблицы действий и таблицы переходов

Для построения таблицы действий и таблицы переходов необходимо выполнить следующие шаги:

1. **Построение множества состояний**: Используя алгоритм построения множества состояний (например, алгоритм Эрли или алгоритм построения множества LR(1) элементов).
2. **Заполнение таблицы действий**: Определение действий парсера (сдвиг, свертка, принятие) для каждого состояния и входного символа.
3. **Заполнение таблицы переходов**: Определение следующего состояния парсера после свертки.

### Пример построения таблицы действий и таблицы переходов

Для простоты, давайте рассмотрим упрощенный пример с грамматикой:

```
S -> E
E -> E + T | T
T -> id
```

#### Построение множества состояний

1. **Состояние 0**:
   - `S' -> .S`
   - `S -> .E`
   - `E -> .E + T`
   - `E -> .T`
   - `T -> .id`

2. **Состояние 1**:
   - `S' -> S.`

3. **Состояние 2**:
   - `S -> E.`
   - `E -> E. + T`

4. **Состояние 3**:
   - `E -> T.`

5. **Состояние 4**:
   - `T -> id.`

6. **Состояние 5**:
   - `E -> E + .T`
   - `T -> .id`

7. **Состояние 6**:
   - `E -> E + T.`

#### Заполнение таблицы действий

| Состояние | id  | +   | $   | S   | E   | T   |
|-----------|-----|-----|-----|-----|-----|-----|
| 0         | s4  |     |     |     | 2   | 3   |
| 1         |     |     | acc |     |     |     |
| 2         |     | s5  |     |     |     |     |
| 3         |     | r3  | r3  |     |     |     |
| 4         |     | r4  | r4  |     |     |     |
| 5         | s4  |     |     |     |     | 6   |
| 6         |     | r1  | r1  |     |     |     |

#### Заполнение таблицы переходов

| Состояние | S   | E   | T   |
|-----------|-----|-----|-----|
| 0         | 1   | 2   | 3   |
| 5         |     |     | 6   |

### Работа LR(1) парсера

Рассмотрим пример разбора строки `id + id`:

1. **Инициализация**:
   - Стек: `0`
   - Ввод: `id + id$`

2. **Основной цикл**:

   **Шаг 1**:
   - Стек: `0`
   - Ввод: `id + id$`
   - Действие: `s4` (сдвиг и переход в состояние 4)
     - Стек: `0 id 4`
     - Ввод: `+ id$`

   **Шаг 2**:
   - Стек: `0 id 4`
   - Ввод: `+ id$`
   - Действие: `r4` (свертка по правилу `T -> id`)
     - Стек: `0 T 3`
     - Ввод: `+ id$`

   **Шаг 3**:
   - Стек: `0 T 3`
   - Ввод: `+ id$`
   - Действие: `r3` (свертка по правилу `E -> T`)
     - Стек: `0 E 2`
     - Ввод: `+ id$`

   **Шаг 4**:
   - Стек: `0 E 2`
   - Ввод: `+ id$`
   - Действие: `s5` (сдвиг и переход в состояние 5)
     - Стек: `0 E 2 + 5`
     - Ввод: `id$`

   **Шаг 5**:
   - Стек: `0 E 2 + 5`
   - Ввод: `id$`
   - Действие: `s4` (сдвиг и переход в состояние 4)
     - Стек: `0 E 2 + 5 id 4`
     - Ввод: `$`

   **Шаг 6**:
   - Стек: `0 E 2 + 5 id 4`
   - Ввод: `$`
   - Действие: `r4` (свертка по правилу `T -> id`)
     - Стек: `0 E 2 + 5 T 6`
     - Ввод: `$`

   **Шаг 7**:
   - Стек: `0 E 2 + 5 T 6`
   - Ввод: `$`
   - Действие: `r1` (свертка по правилу `E -> E + T`)
     - Стек: `0 E 2`
     - Ввод: `$`

   **Шаг 8**:
   - Стек: `0 E 2`
   - Ввод: `$`
   - Действие: `acc` (принятие)
     - Разбор успешно завершен.



---

# заметки

* ### Свертка
	Можно рассматривать восходящий синтаксический анализ как процесс "свертки" строки w к стартовому символу грамматики(S). На каждом шаге свертки(reduction) определенная подстрока, соответсвующая телу продукции, заменяется нетерминалом из заголовка этой продукции(Например: строка - id * id будет на одном из этапов анализа и построения заменена на F * id(так как в грамматикие есть продукция F -> id)).
	Ключевые решения, принимаемые в процессе восходящего анализа - когда выполнять свертку и какую продукуцию принимать. 

## Синтаксический анализ "перенос/свертка"

ПС(перенос/свертка) представляет собой разновилность восходящего анализа, в котором для хранения символа грамматики используется стек, а для хранения оставшейся непроанализированной части входной строки - входной буфер. 

Мы используем сивол `$` для маркироваки дна стека и правого конца буфера входной строки. Изначально стек пуст, буфер содержит полную входную строку `w`:

В процессе сканирования входной строки из буфера слево направо анализатор выполняет нуль и N количество переносов символом из буфера(сдвигая указатель в буфере) в стек, пока не будет готов выполнить светру строки `b` символов грамматики на вершине стека к заголовку соответствующей продукции(left non terminal). 

Анализатор повторяет этот цикл до тех пор, пока стек не будет содержать стартовый символ и входной буфер будет пуст или же пока не встретит ошибку.

Исходное состояние:
Stack: `$`; buffer: `w$` 

Кончное состояние:
Stack: `$S`; buffer: `$`;

Согласно выше сказаному у анализатора могут быть лишь 4 состояния:
1) перенос 
2) свертка
3) принятие
4) ошибка
### Конфликты в процессе RL  анализа

Имееются контекстно-зависимые грамматики, для которых ПС анализ неприменим. 
Пример неоднозначной RL грамматики:
```
	stmt -> if expr then stmt |
			if expr then stmt else stmt | 
			other;
```

Еще одна распространненная причина конфликта - когда у нас есть основа, но содержимого стека и очередного входного символа недостаточно для определения продукции, которая должна испоьзовать свертку. 

### Пункты и RL(1) автомат

Каким образом ПС будет определять, когда следует делать перенос а когда свертку?
LR-анализатор принимает решение о выборе "перенос/свертка" на основе состоянии, которые отслеживают, где именно в процессе синтаксического анализа мы находимся. Состояния представляют собой множество "пунктов". Пунтк грамматики G - продукция с точкой в некоторой позиции  правой части продукции. Например: продукция `A -> XYZ;` дает 4 пункта:
* `A -> .XYZ;`
* `A -> X.YZ;`
* `A -> XY.Z;`
* `A -> XYZ.;`

Продукция `A -> e;`  может генерировать только один пункт: `A -> .;`

Интуитивно, пунт показывает какую часть продукции мы уже просмотрели в данной точке в процессе анализа. 

Например, пункт `A -> .XYZ` указывает, что во входном потоке мы ожидаем встретить строку, порождаемую `XYZ`. Пункт `A -> X.YZ;`  указывает нам на то что мы уже просмотрели подстроку поразжаемую `X` и далее ожидаем встретить подстроку попрождаемую `YZ`. Пункт `A -> XYZ.;` указывает на то что мы уже встретили строку пораждаемую `XYZ` и пора уже свернуть `XYZ` в `A` .

Множество таких пунктов образует основу для построения детерминированного автомата, который используется для принятия решений в процессе синтаксического анализа. В частности, каждое состояние LR(0)-автомата представляет множество пунктов в каноническом наборе. 

Для построения канонического RL(0)-набора мы определяем расширенную грмаматику(`S' -> S`) и две функции: CLOSURE, GOTO;

Назанчение расширенной грамматики это указать анализатору когда остановить анализ(когда в стеке окажется начальный символ `S`) и `$` во входном буфере.

CLOSURE(I) - множество пунктов, построенное из I,  при I - множество пунктов грамматики G;

Алгоримт построения CLOSURE:
1) Изначально в CLOSURE(I) добавляются все пункты из I;
2) Если `A -> a.Bc;`  входит в CLOSURE(I), а `B -> y;` является продукцией, то в CLOSURE(I) добавляется пункт `B -> .y;` - если его там еще нет. Это правило применятеся пока не останеться не добавленых пунктов.
Рассмотрим это на следующей грамматике:

```
E' -> E;
E -> E + T | T;
T -> F * T | F;
F -> id | (E);
```

Если I - множество из одного пунтка: `E' -> E;` то CLOSURE(I) содержит множество пунктов Io. Сначало `E' -> .E;` помещается в CLOSURE(I) соглдасно правилу 1) затем мы дожны добавить все продукции `E` такие как: 
`E -> .E + T;` и `E -> .T;` если их еще нету в CLOSURE(I). Теперь справо от `.` стоит `T`. С ней мы поступаем точно так же рекурсиво добавляем все ее пункты: 
`T -> .id;` и `T -> .(E);` и так далее пока мы не добавим все возможные пункты I.

Разделим множество интересующих нас пунктов на два класса:
1) Базисыне пункты(пункты ядра) kernel items - начальный пункт(`S' -> .S;`) и все пункты, точка которых расположена не у левого края продукции.
2) Небазисные пункты (nonkernel items) - пункты у которых точки расположены слева

### Функция GOTO(I, X)

GOTO(I, X) - множество пунктов, а X - грамматичсекий символ. Функция используется для определения переходов в RL(0)-автомате. Состояние автомата соответствует множествам пунктов, и GOTO(I, X) указывает переход из состояния I при входном символе X. 

Канонически GOTO(I, X) вычисляется путем рассмотрения пунктов I, в которых `X`  следует непосретсвенно за `.`.

Например:  Если I содержит множество пунктов: {`E' -> E.;`, `E -> E .+ T;`}, то пунтк `E' -> E.;` таковым для GOTO(I, +) не является, зато пункт `E -> E .+ T;` подходит, так как `+` следует непосредственно за `.`. Поэтому мы переносим точку зв `+`, получая пункт `E -> E +. T;`


В алгоритме LR (например, LR(0), SLR(1), LALR(1), LR(1)), **closure** и **go-to** — это две ключевые функции, используемые для построения канонического набора состояний автомата, который распознает грамматику.

Хорошо, давайте разберем **closure** подробнее с примерами, чтобы стало понятнее, как она работает.

---

### Что такое II (состояние автомата)

II — это множество пунктов (items), которое представляет собой "снимок" всех возможных путей разбора в текущий момент. Каждый пункт в II — это правило грамматики с маркером ⋅⋅, указывающим, сколько символов правила уже распознано.

1. **Текущий символ во входном буфере** используется для определения, какое действие выполнить:
    
    - **Перенос (shift)**: Если в II есть пункт, где маркер ⋅⋅ стоит перед терминалом, совпадающим с текущим символом.
    
    - **Свертка (reduce)**: Если в II есть пункт, где маркер ⋅⋅ стоит в конце правила.
    
    - **Принятие (accept)**: Если в II есть пункт S→α⋅S→α⋅, где SS — начальный символ грамматики, и во входном буфере остался только символ .
    
    - **Ошибка**: Если ни одно из вышеуказанных действий невозможно.
    
2. **Состояние II** определяет, какие действия доступны в текущий момент, но само по себе оно **не зависит от текущего символа во входном буфере**. Оно зависит от:
    
    - Текущей конфигурации стека.
    
    - Правил грамматики.

---

### closure
Функция **closure** используется в LR-анализе для расширения множества пунктов (items). Пункт (item) — это правило грамматики с маркером `.`, который указывает текущую позицию в разборе. Например:
$$ A \to \alpha \cdot \beta $$
Здесь:
- A — нетерминал,
- \( \alpha \) и \( \beta \) — строки терминалов и нетерминалов,
- `.` — маркер, показывающий, сколько символов уже распознано.

Функция **closure** добавляет к текущему множеству пунктов все пункты, которые могут быть выведены из текущих пунктов через e-переходы (то есть через нетерминалы).

---
### Как работает **closure**?
1. **Исходное множество пунктов**: Начинаем с некоторого множества пунктов \( I \).
2. **Добавление новых пунктов**:
   - Для каждого пункта вида $$ A \to \alpha \cdot B \beta $$ где B — нетерминал в ( I ),
   - Добавляем все пункты $$ B \to \cdot \gamma $$ для каждого правила грамматики $$B \to \gamma$$
3. **Повторение**: Процесс повторяется, пока не перестанут добавляться новые пункты.

### алгоритм вычисления closure(I): 
берем начальный пункт, смотрим следующий символ за точкой и если он нетерминал то получаем список его продукции и добавляем их если еще не были добавлены в I.

Например: стартовый пункт `A -> a.Bc;` `B` - нетерминал и у него есть `B -> b | e;` Тогда мы добавляем сначало `B -> .b` затем смотрим `b` - терминал и значит на нем мы останавливаем. Далее мы добавляем пункт `B -> .e;` и `e` - теримнал и значит тут тоже останавливаемся так как у B больше нету не добавленных пунктов.

---

### Пример 1
Рассмотрим грамматику:
```
S -> A;
A -> aB;
B -> b;
```

Построим **closure** для начального пункта $$S \to \cdot A $$

#### Шаг 1: Исходное множество
$$I = \{ S \to \cdot A \} $$

#### Шаг 2: Применяем closure
- Видим пункт $$S \to \cdot A $$Здесь \( A \) — нетерминал, и есть правило $$A \to aB $$
- Добавляем пункт $$A \to \cdot aB$$

Теперь множество:
$$I = \{ S \to \cdot A, \, A \to \cdot aB \}$$

#### Шаг 3: Проверяем новые пункты
- В пункте $$A \to \cdot aB$$ символ после маркера — терминал \( a \), поэтому новых пунктов не добавляем. Если бы символ был бы не терминалом, то по рекурсии мы бы его добавили как и предыдущий пункт.

#### Итоговое множество после closure:
$$I = \{ S \to \cdot A, \, A \to \cdot aB \}$$

### для чего closure(I)

Функция **closure** расширяет множество пунктов, добавляя все пункты, которые могут быть достигнуты через переходы по нетерминалам. Это необходимо для того, чтобы:

1. Учесть все возможные пути разбора в текущем состоянии автомата.
2. Построить корректные переходы между состояниями.


Конечная цель LR-анализа — построить **детерминированный конечный автомат (DFA)**, который сможет распознавать строки, допустимые данной грамматикой. Этот автомат строится на основе **канонического набора состояний**, каждое из которых представляет собой множество пунктов.

Функция **closure** используется для построения этих состояний:

1. Каждое состояние автомата — это множество пунктов, замкнутое с помощью **closure**.
    
2. Переходы между состояниями строятся с помощью функции **go-to**, которая использует **closure** для вычисления новых состояний.

Функция **go-to** играет ключевую роль в определении того, в какое состояние (или пункт) перейти после выполнения **переноса (shift)** или **свертки (reduce)**. Давайте разберем это подробнее.

---

Функция **go-to** принимает:

1. Текущее состояние (множество пунктов).
2. Символ X (терминал или нетерминал).

Она возвращает новое состояние, в которое можно перейти из текущего состояния по символу XX.

---

### Как работает **go-to**?

1. **Для переноса (shift)**:
    
    - Если X — терминал, то **go-to** определяет, в какое состояние перейти после переноса X на стек.
    
    - Например, если в текущем состоянии есть пункт `A→α⋅Xβ`, то после переноса X мы переходим в состояние, соответствующее пункту `A→αX⋅β`.
    
2. **Для свертки (reduce)**:
    
    - Если X — нетерминал, то **go-to** определяет, в какое состояние перейти после свертки.
    
    - Например, если мы свернули несколько символов на стеке в нетерминал XX, то **go-to** определяет, какое состояние положить на стек после этого.

---

### Формальное определение

Функция **go-to** определяется следующим образом:

$$goto(I,X)=closure({A→αX⋅β∣A→α⋅Xβ∈I})go-to(I,X)=closure({A→αX⋅β∣A→α⋅Xβ∈I})$$  
где:

- I — текущее состояние (множество пунктов),
- X — символ (терминал или нетерминал),
- closureclosure — функция замыкания.










---
---



### Весь алгоритм целиком

### Алгоритм LR-анализа

#### Вход:
- Грамматика \( G \) с правилами вида $$ A \to \alpha $$
- Входная строка `w`, заканчивающаяся символом `$`.

#### Выход:
- Дерево разбора, если строка \( w \) принадлежит языку грамматики \( G \).
- Ошибка, если строка \( w \) не принадлежит языку грамматики \( G \).

---

### Шаги алгоритма:

#### 1. Инициализация
- Постройте начальное состояние $$I_0$$ как **closure** от начального пункта $$S' \to \cdot S$$, где \( S' \) — новый стартовый символ, добавленный к грамматике.
- Инициализируйте стек: $$[I0]$$
- Инициализируйте входной буфер: \( w \).

---

#### 2. Основной цикл
Пока входной буфер не пуст или на стеке не останется только \( S' \):
1. **Текущее состояние**:
   - Пусть \( I \) — состояние на вершине стека.
   - Пусть \( X \) — текущий символ во входном буфере.

2. **Если в \( I \) есть пункт с маркером перед терминалом**:
   - Если \( X \) — терминал, и в \( I \) есть пункт $$A \to \alpha \cdot X \beta$$, выполните **перенос (shift)**:
     - Перенесите \( X \) на стек.
     - Вычислите новое состояние $$I_{\text{new}} = \text{goto}(I, X)$$
     - Поместите $$I_{\text{new}}$$ на стек.
     - Перейдите к следующему символу во входном буфере.

3. **Если в \( I \) есть пункт с маркером в конце правила**:
   - Если в \( I \) есть пункт $$A \to \alpha \cdot$$, выполните **свертку (reduce)**:
     - Удалите \( |\alpha| \) символов и состояний с вершины стека.
     - Сверните \( \alpha \) в нетерминал \( A \).
     - Поместите \( A \) на стек.
     - Вычислите новое состояние $$I_{\text{new}} = \text{goto}(I_{\text{prev}}, A)$$, где $$I_{\text{prev}}$$ — состояние, которое было на стеке до удаления \( \alpha \).
     - Поместите $$I_{\text{new}}$$ на стек.

4. **Если в \( I \) есть пункт с маркером перед нетерминалом**:
   - Если в \( I \) есть пункт $$A \to \alpha \cdot B \beta$$, где \( B \) — нетерминал, выполните **closure**:
     - Добавьте все пункты $$B \to \cdot \gamma$$ для каждого правила грамматики $$B \to \gamma$$
     - Вычислите новое состояние $$I_{\text{new}} = \text{goto}(I, B)$$
     - Поместите $$I_{\text{new}}$$ на стек

5. **Если на стеке остался только \( S' \), а входной буфер пуст**:
   - Строка принята. Постройте дерево разбора на основе выполненных сверток.

6. **Если ни одно из вышеуказанных действий невозможно**:
   - Строка отвергается. Выведите ошибку.

---
---



### Рассматрим RL алгоритм построения синтаксического дерева на основе простой грамматике:

Отлично! Давайте разберем процесс разбора строки \( abc \) для грамматики:
```
S' -> S;
S -> a B c;
B -> b | e;
```

### Шаг 1: Инициализация
- **Стек**: \( [I_0] \), где $$I_0 = \{ S' \to \cdot S, \, S \to \cdot aBc \}$$
- **Входной буфер**: \( abc \).

---

### Шаг 2: Перенос по \( a \)
- **Текущее состояние**: $$I_0 = \{ S' \to \cdot S, \, S \to \cdot aBc \}$$
- **Текущий символ**: \( a \).
- В $$I_0$$ есть пункт $$S \to \cdot aBc$$, где маркер `.` стоит перед \( a \).
- Выполняем **перенос (shift)**:
  - Переносим \( a \) на стек.
  - Вычисляем $$I_1 = \text{goto}(I_0, a) = \text{closure}(\{ S \to a \cdot Bc \}) = \{ S \to a \cdot Bc, \, B \to \cdot b, \, B \to \cdot e \}$$
  - Помещаем \( I_1 \) на стек.
- **Стек**: \( [I_0, a, I_1] \).
- **Входной буфер**: \( bc \).

---

### Шаг 3: Перенос по \( b \)
- **Текущее состояние**: $$I_1 = \{ S \to a \cdot Bc, \, B \to \cdot b, \, B \to \cdot e \}$$
- **Текущий символ**: \( b \).
- В $$I_1$$ есть пункт $$B \to \cdot b$$, где маркер `.` стоит перед \( b \).
- Выполняем **перенос (shift)**:
  - Переносим \( b \) на стек.
  - Вычисляем $$I_2 = \text{goto}(I_1, b) = \text{closure}(\{ B \to b \cdot \}) = \{ B \to b \cdot \}$$
  - Помещаем \( I_2 \) на стек.
- **Стек**: \( [I_0, a, I_1, b, I_2] \).
- **Входной буфер**: \( c \).

#### Замечание

Если бы у нас была не строка "abc" а строка "ac"

то нам нужно было бы в $$I_1$$ искать пункт, где после `.` стоял бы символ `c`, но такого пункта как можно заметить нету, зато неявно видим что пунтк $$B \to \cdot e $$
ведет нас к правильному разбору. Можно за правило взять что если на каком-то этапе выбора подходящего пункта нету, зато есть пункт $$\to .$$ то выбираем этот пункт. В книге дракона даже делалось замечание с тем что бы делать такой пункт по умолчанию, если не найдет другой подходящий пункт из множества. 

---

### Шаг 4: Свертка по (B -> b)
- **Текущее состояние**: $$I_2 = \{ B \to b \cdot \}$$
- Видим пункт $$B \to b \cdot$$, выполняем **свертку (reduce)**.
- Удаляем \( b \) и \( I_1 \) с вершины стека.
- Сворачиваем \( b \) в нетерминал \( B \).
- Помещаем \( B \) на стек.
- Вычисляем новое состояние $$I_3 = \text{goto}(I_1, B)$$

---

1. **Текущее состояние перед сверткой**:
   - $$I_1 = \{ S \to a \cdot Bc, \, B \to \cdot b, \, B \to \cdot e \}$$

   - Ищем в \( I_1 \) пункты, где маркер `.` стоит перед \( B \).
   - В \( I_1 \) есть пункт $$S \to a \cdot Bc$$
   - Сдвигаем маркер за \( B \): $$S \to aB \cdot c$$
   - Применяем **closure** к $$\{ S \to aB \cdot c \}$$
     - Символ после маркера `.` — \( c \) (терминал), поэтому новых пунктов не добавляем.
   - Новое состояние:
     $$ I_3 = \{ S \to aB \cdot c \}$$

3. **Помещаем \( I_3 \) на стек**:
   - Стек: \( [I_0, a, I_3] \).
   - Входной буфер: \( c \).

$$\text{Почему I3=goto(I1,B)?}$$
1. **Текущее состояние перед сверткой**:
    
    - Перед сверткой на стеке были состояния [I0,a,I1,b,I2].
        
    - После удаления b и I1​ стек становится [I0,a].
        
    - Текущее состояние на вершине стека — I1.
        
2. **Вычисляем goto(I1,B)**:
    
    - Ищем в I1 пункты, где маркер ⋅ стоит перед B.
        
    - В I1​ есть пункт S→a⋅Bc.
        
    - Сдвигаем маркер за B: S→aB⋅c.
        
    - Применяем **closure** к {S→aB⋅c}:
        
        - Символ после маркера ⋅ — c (терминал), поэтому новых пунктов не добавляем.
            
    - Новое состояние:
        
        I3={S→aB⋅c}
        
3. **Помещаем I3 на стек**:
    
    - Стек: [I0,a,I3].
        
    - Входной буфер: c.

---

### Шаг 5: Перенос по \( c \)
- **Текущее состояние**: $$I_3 = \{ S \to aB \cdot c \}$$
- **Текущий символ**: \( c \).
- В \( I_3 \) есть пункт $$S \to aB \cdot c$$, где маркер `.` стоит перед \( c \).
- Выполняем **перенос (shift)**:
  - Переносим \( c \) на стек.
  - Вычисляем $$I_4 = \text{goto}(I_3, c) = \text{closure}(\{ S \to aBc \cdot \}) = \{ S \to aBc \cdot \}$$
  - Помещаем \( I_4 \) на стек.
- **Стек**: \( [I_0, a, I_3, c, I_4] \).
- **Входной буфер**: \( \).

---

### Шаг 6: Свертка по S -> aBc
- **Текущее состояние**: $$I_4 = \{ S \to aBc \cdot \}$$
- Видим пункт $$S \to aBc \cdot$$, выполняем **свертку (reduce)**.
- Удаляем \( c \), \( I_3 \), \( B \), \( a \) и \( I_0 \) с вершины стека.
- Сворачиваем \( aBc \) в нетерминал \( S \).
- Помещаем \( S \) на стек.
- Вычисляем новое состояние $$I_5 = \text{goto}(I_0, S)$$
1. **Текущее состояние перед сверткой**:
   - $$I_0 = \{ S' \to \cdot S, \, S \to \cdot aBc \}$$

   - Ищем в \( I_0 \) пункты, где маркер `.` стоит перед \( S \).
   - В \( I_0 \) есть пункт $$S' \to \cdot S$$
   - Сдвигаем маркер за \( S \): $$S' \to S \cdot$$
   - Применяем **closure** к $$ \{ S' \to S \cdot \}$$:
     - Символ после маркера `.` отсутствует, поэтому новых пунктов не добавляем.
   - Новое состояние:
     $$I_5 = \{ S' \to S \cdot \}$$

3. **Помещаем \( I_5 \) на стек**:
   - Стек: \( [I_5] \).
   - Входной буфер: \( \).

---

### Шаг 7: Принятие
- **Текущее состояние**: $$I_5 = \{ S' \to S \cdot \}$$
- **На стеке**: \( S \).
- **Во входном буфере**: \( \).
- Строка принята.

---

### Итоговое дерево разбора
Дерево разбора для строки \( abc \):

```
      S
     /|\
    a B c
      |
      b
```
