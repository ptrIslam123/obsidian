**Префиксное дерево (Trie) — это особый вид дерева, которое используется для эффективного хранения и поиска строк или последовательностей символов. Оно также известно как "дерево префиксов" или "нагруженное дерево" (prefix tree или digital tree). Префиксное дерево особенно полезно для задач автодополнения, проверки орфографии, сортировки строк и других задач, связанных с обработкой текста.**

### Асимптотика базовых методов

- **Временная сложность**:
  - **Вставка**: O(m), где `m` — длина строки.
  - **Поиск**: O(m), где `m` — длина строки.
  - **Удаление**: O(m), где `m` — длина строки.
- **Пространственная сложность**: O(n * m), где `n` — количество строк, а `m` — средняя длина строки.

### Структура префиксного дерева

В базовой реализации каждый узел дерева содержит один символ и указатели на дочерние узлы. Ключ узла не хранится в явном виде — он вычисляется как путь от корня до узла.

Выглядит это следующим образом:

![[Pasted image 20240815181029.png]]

В префиксном дереве (Trie) узел обычно хранит следующую информацию:

1. **Указатели на дочерние узлы**: Каждый узел содержит массив указателей на свои дочерние узлы. Количество указателей зависит от алфавита, который вы используете. Например, для английского алфавита это будет 26 указателей (по одному на каждую букву).

2. **Булевый флаг**: Флаг `isEndOfWord` указывает, является ли данный узел концом какого-либо слова. Это позволяет определить, что последовательность символов, которая привела к этому узлу, представляет собой слово.

```c++
// Абстрактное описание одного узла в префиксном дереве
struct Node {
	/* Для простоты примера набор указателей на дочерние узлы выполнен */
	/* как связанный список */
    std::list<Node*> children;

	/* Явно хранимый символ */
	/* Обычно симол как бы храниться на ребре между узлами */
	/* Но в реализации узел хранит символ */
	char character; 

	/* Маркер: Этот ужел заканчивает одно слово или же нет */
    bool isEndOfWord;
};
```


### Основные операции

### Вставка: Insert(Str)

Вставка узла в префиксное дерево (Trie) происходит посимвольно, начиная с корневого узла. Вот пошаговое описание процесса вставки:

1. **Начинаем с корневого узла**: Начинаем с корневого узла, который обычно представлен как пустая строка.

2. **Проходим по символам строки**: Для каждого символа в строке, которую нужно вставить, выполняем следующие действия:
    
    - Проверяем, существует ли у текущего узла дочерний узел, соответствующий текущему символу.
        
    - Если такой узел существует, переходим к нему.
        
    - Если такого узла нет, создаем новый узел для текущего символа и делаем его дочерним узлом текущего узла. Затем переходим к этому новому узлу и так для всех символов, которых еще нет в префиксном дереве.
        
3. **Отмечаем конец строки**: После того как прошли по всем символам строки и перешли к последнему узлу, устанавливаем флаг `isEndOfWord` в `true`, чтобы указать, что этот узел является концом строки.

```c++
// Примерная реализация вставки строки в префиксное дерево
void Trie::insert(const std::string_view word) {
	Node* current = root;
	for (const char symbol : word) {
		// наша задача это найти узел соответсвующий текущему символу
		Node* child = nullptr;
		for (child : children) {
			if (child->character == symbol) {
				break;
			}
		}
		
		if (child == nullptr) {
			// Если такого узла еще нет, то создаем его и добавляем в список
			child = new Node(symbol);
			current->children.push_back(child);
		} else {
			// Если же данный символ узе был добавлен(возможно как часть
			// дргуого слова),то просто переходим к следующему символу 
			// а current делаем этот узел что бы дальнейше 
			// на него навесть остальные узлы с оставшимися символами
			current = child;
		}
	}
	// Когда мы наконец добавим все символы, то 
	// последний узел помечаем как конец слова!
	current->isEndOfWord = true;
}
```

`ВАЖНО:` Префиксное дерево (Trie) может иметь дублирование узлов на некоторых путях, если у строк разные префиксы. Однако, это дублирование происходит только для уникальных префиксов, а общая часть строк (суффиксы) будет использоваться совместно при совпадении части префиксов.

Например: Рассмотрим две строки: "dotogovo", "edgovo";

У обооих общий суфикс: "govo", но разные префиксы: "doto", "ed"; соответвенно произоидет дублирование цепочти узлов ("govo"), так как у них разные префиксы.

```
Root
|
|-- d
|   |
|   |-- o
|       |
|       |-- t
|           |
|           |-- o
|               |
|               |-- g
|                   |
|                   |-- o
|                       |
|                       |-- v
|                           |
|                           |-- o (конец слова для "dotogovo")
|
|-- e
    |
    |-- d
        |
        |-- g
            |
            |-- o
                |
                |-- v
                    |
                    |-- o (конец слова для "edgovo")
```

Экономия по памяти в виде переиспользования узлов будет происходить если наоборот, префиксы одинаковые, но суфиксы разные. Тогда префикс будет общим, а уникальными цепочками будут суфиксы.

Например: Рассмотрим опять пару строк: "textda", "texmic"

У нас будет одно общая префиксная цепочка: "tex" и два уникальных суфикса: "tda", "mic"

```
Root
|
|-- t
    |
    |-- e
        |
        |-- x
            |
            |-- t
                |
                |-- d
                |   |
                |   |-- a (конец слова для "textda")
                |
                |-- m
                    |
                    |-- i
                        |
                        |-- c (конец слова для "texmic")
```

### Поиск

Алгоритм поиска в префиксном дереве (Trie) заключается в посимвольном проходе от корневого узла к узлам, соответствующим символам искомой строки. Вот пошаговое описание алгоритма:

1. **Начинаем с корневого узла**: Начинаем с корневого узла, который обычно представлен как пустая строка.
    
2. **Проходим по символам строки**: Для каждого символа в строке, которую нужно найти, выполняем следующие действия:
    
    - Проверяем, существует ли у текущего узла дочерний узел, соответствующий текущему символу.
        
    - Если такой узел существует, переходим к нему.
        
    - Если такого узла нет, значит, строка не найдена, и мы завершаем поиск.
        
3. **Проверяем конец строки**: После того как прошли по всем символам строки и перешли к последнему узлу, проверяем флаг `isEndOfWord`. Если он установлен в `true`, значит, строка найдена. В противном случае, строка не найдена.

```c++
bool Trie::find(const std::string_view word) {
	Node* current = root;
	// Процесс поиска символов будет поисходит по всем символам заданого слова
	for (const char symbol : word) {
		bool foundSymbol = false;
		// просматриваем всех детей данного узла
		for (Node* child : current->children) {
			if (child->character == symbol) {
				// если нужный символ найдет переходим к следующему искомому
				// символу в дереве
				current = child;
				foundSymbol = true;
				break;
			}
		}
		
		if (!foundSymbol) {
			// если же на текущем узле поддерева/дерева мы не нашли 
			// текущий искомый символ, значит дерево не содержит 
			// искомую строку
			return false;
		} else {
			// продолжаем поиск со следующешл символа искомой строки
			continue;
		}
	}
	// Если мы дошли до конца(проверили все символы искомой строки)
	// значит эта строка содержиться в дереве
	return current->isEndOfWord; // true
}
```

### Удаление

- **Поиск узла**:
    
    - Начинаем с корневого узла и итерируем по символам строки, чтобы найти узел, соответствующий последнему символу строки.
    - Если узел не найден, строка не существует в Trie, и операция удаления завершается.
    
- **Проверка конца слова**:
    
    - Если узел найден, проверяем, является ли он концом слова (то есть, установлен ли флаг `isEndOfWord`).
    - Если флаг не установлен, это означает, что строка не существует в Trie, и удаление не требуется.
    
- **Удаление флага**:
    
    - Удаляем флаг `isEndOfWord` у найденного узла, чтобы указать, что строка больше не существует в Trie.
    
- **Обратный проход и удаление пустых узлов**:
    
    - После удаления флага, необходимо пройти обратно по узлам, начиная с последнего символа строки.
    - Удаляем узлы, если они не имеют других потомков и не являются концами других слов. Это помогает сжать дерево и удалить ненужные узлы.
    
- **Завершение**:
    
    - Продолжаем удаление узлов до тех пор, пока не достигнем корневого узла или пока не найдем узел, который имеет других потомков или является концом другого слова.

## Применение

Префиксное дерево (Trie) хорошо подходит для решения задач, связанных с обработкой и поиском строк, особенно когда требуется быстрый доступ, вставка и поиск. Вот несколько сценариев, где префиксное дерево может быть особенно полезным:

1. **Автодополнение и предложение слов**: Префиксное дерево позволяет эффективно находить все слова, начинающиеся с заданного префикса. Это делает его идеальным для реализации функций автодополнения в поисковых системах, текстовых редакторах и мобильных приложениях.

2. **Проверка орфографии**: Префиксное дерево можно использовать для хранения словаря и быстрого поиска слов. Это позволяет эффективно проверять орфографию в текстовых редакторах и системах обработки текста.

3. **Сортировка строк**: Префиксное дерево может быть использовано для сортировки строк лексикографически. Вставка строк в дерево автоматически упорядочивает их по префиксам.

4. **IP маршрутизация**: В сетевых приложениях, таких как маршрутизация пакетов, префиксное дерево может использоваться для хранения и быстрого поиска маршрутов по префиксам IP-адресов.

5. **Кодирование и сжатие данных**: Префиксное дерево может помочь в реализации алгоритмов кодирования и сжатия данных, таких как кодирование Хаффмана.

6. **Поиск подстрок**: Префиксное дерево может быть использовано для быстрого поиска всех вхождений заданной подстроки в большом тексте.

7. **Телефонная книга**: В мобильных приложениях и настольных программах для управления контактами префиксное дерево может использоваться для быстрого поиска и фильтрации контактов по имени или номеру телефона.

Преимущества использования префиксного дерева включают:
- **Быстрый поиск**: Вставка и поиск строк выполняются за время, пропорциональное длине строки, что делает его очень быстрым для задач, связанных с префиксами.
- **Эффективное использование памяти**: Хотя префиксное дерево может потреблять больше памяти по сравнению с другими структурами данных, оно эффективно использует память за счет совместного использования общих префиксов.

Однако, префиксное дерево может быть неэффективным в случаях, когда строки имеют мало общих префиксов или когда требуется поиск подстрок, а не префиксов. В таких случаях могут быть более подходящими другие структуры данных, такие как хеш-таблицы или суффиксные деревья.