**Фибоначчевы кучи — это особый тип приоритетных куч, которые обеспечивают эффективные операции слияния и извлечения минимального элемента. Они основаны на свойствах Фибоначчевых чисел и имеют несколько ключевых характеристик.**

## Основные характеристики

1. **Связанные списки**: Фибоначчевы кучи состоят из набора деревьев, которые могут быть представлены в виде связанных списков. Каждое дерево в куче имеет определенную структуру.
2. **Деревья**: Каждое дерево в Фибоначчевой куче является неупорядоченным и может быть представлено как d-куча (где d — это число детей у каждого узла(степень узла)). Однако чаще всего используется двоичная структура (2-куча), где у каждого узла может быть два дочерних узла.
3. **Минимум/Максимум**: В Фибоначчевых кучах обычно реализуется минимум, то есть корень каждого дерева является наименьшим элементом в этом дереве. Это означает, что Фибоначчева куча может быть использована для реализации min-кучи. Если вам нужна max-куча, структура будет аналогичной, но с изменением порядка.
4. **Свойства**:
    
    - Каждое дерево в куче соответствует определенному числу Фибоначчи.
    - Куча поддерживает операции, такие как вставка, слияние, извлечение минимального элемента и уменьшение ключа, с эффективной временной сложностью.
    

## Операции

- **Вставка**: O(1) амортизированное время.
- **Слияние**: O(1) амортизированное время.
- **Извлечение минимального элемента**: O(log n) амортизированное время.
- **Уменьшение ключа**: O(1) амортизированное время.











## Асимптотика базовых методов
* **Insert - O(1)**
* **GetMin - O(1)**
* **Merge - O(1)**
* **DecreaseKey - O(1)**
* **ExtractMin  - O(logn)**

**Фибоначчева куча - набор деревьев(d-куч), которые должны удовлетворять тому что бы узел/корень был максимальным в дереве/поддереве(max-кучи) или наименьшим(min-кучи) и корни всех этих деревьев соединины в двухсвязанный список. Вводиться понятие ранг/степень вершины - количество дочерних подузлов этого узла.**

![[Pasted image 20240810231425.png]]

```c++
//! Абстрактное описание одной ноды фибоначчевой кучи
template<typename T>
struct Node {
	T value;
	/* Каждая нода содержит список своих подузлов */
	Node* firstChild;
	Node* lastChild;
	/* Указатель на родителя */
	Node* parent;
	
	/* Указатели на следующий и предыдущий корни */
	/* Эти указатели актуальны только для корневых уздлов */
	Node* nextRoot;
	Node* prevRoot;
	
	/* Ранг/степень узла */
	int degree; 
	
	/* Флаг указывает что у этого узла удаляля/вырезался один из подузлов */
	/* по дефолту оно имеет значение false и так же когда эта нода перемещается */
	/* в список корней то это поле так же задается как fasle */
	bool mark;  
};

```

* Insert(X1): Изначально у нас есть пустой список корней. При вставке нового элемента X, создаем новый корень и добавляем элемент в этот корень а сам же корень вставляем в список корней. Если выполняется операция Insert(X2), повторяем тот же процесс: создаем новый корень для X2 и добавляем его в список корней.  Как можно озаметить, на начальном этапе получается просто обычный список корней(и это никак не противоречит структуре данной кучи), но при дальнейших операциях структура дерева будет улучшаться. Вставка нового корня в конец списка выполняется за O(1).

* GetMin(): В нашей структуре кучи мы храним указатель на минимальный узел. Таким образом, мы можем вернуть этот указатель или значение по нему за O(1), просто обновляя его при вставках и удалениях. Для операции вставки это просто: при пустой куче первый вставленный элемент становится минимальным, а при вставке нового элемента в непустую кучу, мы сравниваем его с текущим минимумом и обновляем при необходимости.

* Merge(Other Fibonacci Heap): Эта операция очень простая. Поскольку корень всегда является наименьшим или наибольшим, и мы храним отдельно указатель на самый минимальный или максимальный элемент в куче, достаточно сравнить их и обновить указатель на минимальный или максимальный. Затем просто вставьте начало списка корней другой кучи (Other Fibonacci Heap) в конец списка корней исходной кучи.

* ExtractMin() - Первый шаг очень простой, мы всегда храним указатель на минимум, это то что мы должны вернуть, но затем возникает вопрос. Удаление минимального узла могло повлеч за собой нарушение инвариантов деревьев(корневой узел должен быть всегда наименьшим в дереве/поддереве). Так вот, у нас указатель на минимальный узел, у этого узла есть список под узлов. Значит, мы экстрактим корень минимального узла и теперь у нас являются два списка корней/узлов. Первый список корней это наш список корней нашей кучи а втотрой список образуется после экстракта минимального узла, ведь у этого узла остался список узлов и вот этот список мы вставляем в конец нашего списка корней. На этом шаге у нас есть минимальный элемент кучи а так же мы исправили нарушенные инварианты кучи после экстракта. Осталась последняя деталь, если бы не она, то опрерация ExtractMin была бы за O(1), нам нужно теперь пробежаться по корням и обновить указатель на минимальный узел и так же поменить этот узел как помеченый(mark = true). Стандартно операция "причесывания" кучи/дерева и нахождения указателя на новый минимум называестся Consolidate().

* Consolidate() - Для данной операции нам нужно ввести новое определение. Пусть D(n) - максимально возможный ранг/степень узла в куче на n элементах. Как правило D(n) = O(logn). Значит, мы заводим массив длины D(n), где будем хранить каких рангов у меня есть корни. Как это происходит. Вот у нас во время процессе Consolidate() образовался набор корней с разными рангами, наша задача проитись по всем этим вершинам и в каждой из низ найти пару корней с одинаковыми рангами. Когда мы встретили два корня с рагами k, мы должны эти два корня слить в один корень(из двуз деревьев получить одно), для этого мы сравниваем значения в этих двух корнях и делаем корневых тот корень, чье значение меньше второго и второй корень становиться подузлом/поддеревов первого. При этой у полуившегося дерева/корня ранг увеличивается на 1, так как к нему присоединился еще один узел(в итоге после этой операции из двух корней/узлов с рангом к получается одно дерево/корень с рангом к + 1). Этот новый корень будет сохранен в тот самый массив длины D(n), если изначально корень с рангом k был один то просто его сразу добовляем в массив для консолидации и если при обьединений двух других корней образуется корень с рангом k то далее по рекурсии будет мержить эти два корня в один с рангом k + 1 и так далее для всех корней. Время работы этого алгоритма количество корней и потребляет памяти D(n). Причем мы утверждаем(аксиоматически) что размера массива достаточно для консолидации всех корней. В процессе консолидации мы так же может обновлять указатель на минимальный узел/корень.

* DecreaseKey(Node* node) - Нам дали некоторый указатель на ноду/узел и попросили уменьшить значение/приоритет. Проблема в том что из-за этого снова могло нарушиться своиство деревьев что узловой элемент всегла наименьший в дереве/поддереве. Как мы это будем делать? Мы просто переместим/вставим эту вершину(Node* node) в список корней уже с уменьшеным приоритетом и так же нужно уменьшить ранг/степень у родительского узла перемещаемой/вставляемой вершины на единицу, так как мы удалили у него один узел. Так же нужно у перемещенной вершины mark = false. ВАЖНОЕ ЗАМЕЧАНИЕ: Нельзя просто так вырезать и вставлять детей не корневых узлов больше чем 1. Если это делать, то это в будущем ухудщит асимптотику остальных методов. (Возможно что это как-то влияет на операция ExtratctMin, так как после экстракта узла мы должны выполнить Consolidate() и проитись по всем корневым элементам списка, если при DecreaseKey() мы будем безконтрольно вырезать и вставлять в список корней узлы то у нас операция ExtratcMin() уже не будет O(logn)) Для того что бы отслеживать эти ситуации мы и ввели поле mark в узле.
1. **Уменьшение ключа**: Установите ключ узла `node` в новое значение.
    
2. **Проверка условия**: Если узел `node` является корнем или новый ключ не нарушает свойство кучи (т.е. новый ключ не меньше ключа родителя), то завершите операцию.
    
3. **Вырезание узла**: Вырежьте узел `node` из его текущего положения в дереве и добавьте его в список корней.
    
4. **Обновление указателя на минимальный узел**: Проверьте, не стал ли узел `node` новым минимальным узлом. Если да, обновите указатель на минимальный узел.
    
5. **Обработка родительского узла**:
    
    - Если родитель узла `node` не является корнем и его поле `mark` равно `false`, установите `mark` в `true`.
        
    - Если родитель узла `node` не является корнем и его поле `mark` равно `true`, вырежьте родительский узел и добавьте его в список корней. Сбросьте поле `mark` родителя в `false`.
        
6. **Рекурсивная обработка предков**: Повторите шаг 5 для родителя родителя (и так далее до корня) до тех пор, пока не встретится корень или узел с `mark` равным `false`.
    
7. **Сжатие дерева**: После вырезания узлов может потребоваться сжатие дерева для поддержания его структуры. Это делается путем объединения деревьев с одинаковым степенью (количеством детей).