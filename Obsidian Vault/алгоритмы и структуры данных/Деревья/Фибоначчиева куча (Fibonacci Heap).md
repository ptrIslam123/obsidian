**Фибоначчевы кучи — это особый тип приоритетных куч, которые обеспечивают эффективные операции слияния и извлечения минимального элемента. Они основаны на свойствах Фибоначчевых чисел и имеют несколько ключевых характеристик. Фибоначчева куча - набор деревьев(d-куч), которые должны удовлетворять тому что бы узел/корень был максимальным в дереве/поддереве(max-кучи) или наименьшим(min-кучи) и корни всех этих деревьев соединины в двухсвязанный список. Вводиться понятие ранг/степень вершины - количество дочерних подузлов этого узла.**

![[Pasted image 20240810231425.png]]
## Основные характеристики

1. **Связанные списки**: Фибоначчевы кучи состоят из набора деревьев, которые могут быть представлены в виде связанных списков. Каждое дерево в куче имеет определенную структуру.
2. **Деревья**: Каждое дерево в Фибоначчевой куче является неупорядоченным и может быть представлено как d-куча (где d — это число детей у каждого узла(степень узла)). Однако чаще всего используется двоичная структура (2-куча), где у каждого узла может быть два дочерних узла.
3. **Минимум/Максимум**: В Фибоначчевых кучах обычно реализуется минимум, то есть корень каждого дерева является наименьшим элементом в этом дереве. Это означает, что Фибоначчева куча может быть использована для реализации min-кучи. Если вам нужна max-куча, структура будет аналогичной, но с изменением порядка.
4. **Свойства**:
    
    - Каждое дерево в куче соответствует определенному числу Фибоначчи.
    - Куча поддерживает операции, такие как вставка, слияние, извлечение минимального элемента и уменьшение ключа, с эффективной временной сложностью.
    
## Асимптотика базовых методов
* **Insert - O(1)**
* **GetMin - O(1)**
* **Merge - O(1)**
* **DecreaseKey - O(1)**
* **ExtractMin  - O(logn)**

```c++
//! Абстрактное описание одной ноды фибоначчевой кучи
template<typename T>
struct Node {
	T value;
	/* Каждая нода содержит список своих подузлов */
	Node* firstChild;
	Node* lastChild;
	/* Указатель на родителя */
	Node* parent;
	
	/* Указатели на следующий и предыдущий корни */
	/* Эти указатели актуальны только для корневых уздлов */
	Node* nextRoot;
	Node* prevRoot;
	
	/* Ранг/степень узла */
	int degree; 
	
	/* Флаг указывает что у этого узла удаляля/вырезался один из подузлов */
	/* по дефолту оно имеет значение false и так же когда эта нода перемещается */
	/* в список корней то это поле так же задается как fasle */
	bool mark;  
};

```

* **Insert(X1):** Изначально у нас есть пустой список корней. При вставке нового элемента X, создаем новый корень и добавляем элемент в этот корень а сам же корень вставляем в список корней. Если выполняется операция Insert(X2), повторяем тот же процесс: создаем новый корень для X2 и добавляем его в список корней.  Как можно озаметить, на начальном этапе получается просто обычный список корней(и это никак не противоречит структуре данной кучи), но при дальнейших операциях структура дерева будет улучшаться. Вставка нового корня в конец списка выполняется за O(1).

* **GetMin():** В нашей структуре кучи мы храним указатель на минимальный узел. Таким образом, мы можем вернуть этот указатель или значение по нему за O(1), просто обновляя его при вставках и удалениях. Для операции вставки это просто: при пустой куче первый вставленный элемент становится минимальным, а при вставке нового элемента в непустую кучу, мы сравниваем его с текущим минимумом и обновляем при необходимости.

* **Merge(Other Fibonacci Heap):** Эта операция очень простая. Поскольку корень всегда является наименьшим или наибольшим, и мы храним отдельно указатель на самый минимальный или максимальный элемент в куче, достаточно сравнить их и обновить указатель на минимальный или максимальный. Затем просто вставьте начало списка корней другой кучи (Other Fibonacci Heap) в конец списка корней исходной кучи.

* **ExtractMin()**: Первый шаг очень простой, мы всегда храним указатель на минимум, это то, что мы должны вернуть. Однако, удаление минимального узла может нарушить инварианты деревьев (корневой узел должен быть всегда наименьшим в дереве/поддереве). У минимального узла есть список дочерних узлов. Мы извлекаем корень минимального узла и теперь у нас есть два списка корней/узлов. Первый список корней — это наш список корней нашей кучи, а второй список образуется после извлечения минимального узла, ведь у этого узла остался список узлов, который мы вставляем в конец нашего списка корней. На этом шаге у нас есть минимальный элемент кучи, и мы исправили нарушенные инварианты кучи после извлечения. Осталась последняя деталь: если бы не она, то операция ExtractMin была бы за O(1). Нам нужно теперь пробежаться по корням и обновить указатель на минимальный узел,. Стандартно операция "причесывания" кучи/дерева и нахождения указателя на новый минимум называется Consolidate().

* **Consolidate()**: Для данной операции нам нужно ввести новое определение. Пусть D(n) — максимально возможный ранг/степень узла в куче из n элементов. Как правило, D(n) = O(log n). Значит, мы заводим массив длины D(n), где будем хранить корни различных рангов. Во время процесса Consolidate() у нас есть набор корней с разными рангами. Наша задача — пройтись по всем этим вершинам и найти пары корней с одинаковыми рангами. Когда мы встречаем два корня с рангами k, мы должны объединить их в один корень. Для этого сравниваем значения в этих двух корнях и делаем корнем тот, чье значение меньше, а второй корень становится дочерним узлом первого. Ранг полученного дерева/корня увеличивается на 1, так как к нему присоединился еще один узел. Новый корень сохраняется в массив длины D(n). Если изначально корень с рангом k был один, он просто добавляется в массив для консолидации. Если при объединении двух других корней образуется корень с рангом k, то далее по рекурсии будет объединять эти два корня в один с рангом k + 1 и так далее для всех корней. Время работы этого алгоритма зависит от количества корней и потребляет памяти D(n). Мы утверждаем, что размер массива достаточен для консолидации всех корней. В процессе консолидации мы также можем обновлять указатель на минимальный узел/корень.
* DecreaseKey(Node* node) - Нам дали некоторый указатель на ноду/узел и попросили уменьшить значение/приоритет. Проблема в том что из-за этого снова могло нарушиться своиство деревьев что узловой элемент всегла наименьший в дереве/поддереве. Как мы это будем делать? Мы просто переместим/вставим эту вершину(Node* node) в список корней уже с уменьшеным приоритетом и так же нужно уменьшить ранг/степень у родительского узла перемещаемой/вставляемой вершины на единицу, так как мы удалили у него один узел. Так же нужно у перемещенной вершины mark = false. ВАЖНОЕ ЗАМЕЧАНИЕ: Нельзя просто так вырезать и вставлять детей не корневых узлов больше чем 1. Если это делать, то это в будущем ухудщит асимптотику остальных методов. (Возможно что это как-то влияет на операция ExtratctMin, так как после экстракта узла мы должны выполнить Consolidate() и проитись по всем корневым элементам списка, если при DecreaseKey() мы будем безконтрольно вырезать и вставлять в список корней узлы то у нас операция ExtratcMin() уже не будет O(logn)) Для того что бы отслеживать эти ситуации мы и ввели поле mark в узле.

* **DecreaseKey(Node node)**: Нам дали некоторый указатель на узел и попросили уменьшить его значение/приоритет. Это может нарушить свойство кучи, что узловой элемент всегда наименьший в дереве/поддереве. Мы перемещаем этот узел в список корней с уменьшенным приоритетом и уменьшаем ранг/степень родительского узла перемещаемого узла на единицу(если это не корневой узел), так как мы удалили у него один узел. У перемещенного узла устанавливаем `mark = false`. **Важное замечание**: Нельзя просто так вырезать и вставлять детей не корневых узлов более одного раза. Это может ухудшить асимптотику остальных методов, особенно ExtractMin(), так как после извлечения узла мы должны выполнить Consolidate() и пройтись по всем корневым элементам списка. Для отслеживания этих ситуаций мы ввели поле `mark` в узле.
	1. **Уменьшение ключа**: Установите ключ узла `node` в новое значение.
	
	2. **Проверка условия**: Если узел `node` является корнем или новый ключ не нарушает свойство кучи (т.е. новый ключ не меньше ключа родителя), то завершите операцию.
	
	3. **Вырезание узла**: Вырежьте узел `node` из его текущего положения в дереве и добавьте его в список корней.
	
	4. **Обновление указателя на минимальный узел**: Проверьте, не стал ли узел `node` новым минимальным узлом. Если да, обновите указатель на минимальный узел.
	
	5. **Обработка родительского узла**:
	
	    - Если родитель узла `node` не является корнем и его поле `mark` равно `false`, установите `mark` в `true`.
	    
	    - Если родитель узла `node` не является корнем и его поле `mark` равно `true`, вырежьте родительский узел и добавьте его в список корней. Сбросьте поле `mark` родителя в `false`.
	    
	6. **Рекурсивная обработка предков**: Повторите шаг 5 для родителя родителя (и так далее до корня) до тех пор, пока не встретится корень или узел с `mark` равным `false`.
	
	7. **Сжатие дерева**: После вырезания узлов может потребоваться сжатие дерева для поддержания его структуры. Это делается путем объединения деревьев с одинаковым степенью (количеством детей).