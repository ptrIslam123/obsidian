## Вступление

Структуры данных такие как **HashSet** могут использоваться для небольшого набора данных, позволяя проверять принадлежность элемента множеству. При этом использование проверки принадлежности элемента на большом наборе данных может быть затратным. Временная и пространственная сложность могут быть линейными в худшем случае.

Вероятностные структуры данных предоставляют постоянную временную и пространственную сложность за счет предоставления недетерминированного ответа.

**Фильтр Блума (Bloom Filter) — это вероятностная структура данных, которая позволяет эффективно проверять принадлежность элемента к множеству. Он был предложен Бертоном Хоппером Блумом в 1970 году. Фильтры Блума широко используются в различных областях, таких как база данных, сети, распределенные системы и другие, где требуется быстрая проверка наличия элемента в большом наборе данных.**

### Основные характеристики фильтра Блума:

1. **Вероятностный характер**: Фильтр Блума может ошибочно ответить "да" (ложноположительный результат), но никогда не ошибается, отвечая "нет" (ложноотрицательный результат). Это означает, что если фильтр Блума говорит, что элемент не входит в множество, то элемент действительно отсутствует. Но если фильтр говорит, что элемент входит в множество, то это может быть не так.

3. **Компактность**: Фильтры Блума требуют значительно меньше памяти, чем другие структуры данных, такие как хеш-таблицы, для хранения того же количества элементов.

4. **Статический или динамический**: Фильтры Блума могут быть статическими (размер фиксирован) или динамическими (размер может изменяться).

## Как работает фильтр Блума?

Фильтр Блума как структура данных представляется массивом битов длины _n_ как показано на рисунке ниже. Позиции сегментов представлены индексами от 0 до 9 для массива битов длиной 10. Все биты в фильтре Блума имеют нулевое значение при инициализации, что соответствует пустому фильтру. Фильтр Блума не хранит значение элемента, а только сохраняет набор битов идентифицирующих его после вычисления хеш-функций над значением элемента.

![[Pasted image 20240808114356.png]]

## Как добавляется элемент в фильтр Блума?

Операции выполняемые при добавлении элемента в фильтр Блума:

1. Для элемента вычисляется _k_ хеш-функций;

2. Полученные хеши делятся по модулю на _n_ (по длине массива битов), чтобы получить _k_ значений идентифицирующих позиции битов массива фильтра Блума;

3. Все биты в идентифицирующих позициях устанавливаются в значение равное 1.

**Есть вероятность, что некоторые биты в массиве могут быть установлены в значение 1 многократно ввиду коллизий хеш-функций.**

![[Pasted image 20240808114617.png]]

Сегмент в позиции пять устанавливался в единицу при добавлении и красного, и синего элементов.

## Как проверить принадлежность элемента фильтру Блума?

Операции выполняемые при проверке принадлежности элемента фильтру Блума:

1. Для элемента вычисляются k хеш-функций;

2. Полученные хеши делятся по модулю на n (по длине массива битов), чтобы получить k значений идентифицирующих позиции битов массива фильтра Блума;

3. Выполняется проверка, что полученные сегменты установлены в единицу.

![[Pasted image 20240808114720.png]]

* Если любой из битов имеет нулевое значение, то элемент не добавлялся в фильтр Блума. 
* Если все биты имеют значение один, то элемент **возможно** добавлялся в фильтр Блума. 

**Неопределенность по принадлежности элемента возникает из-за возможности установки некоторых битов при добавлении разных элементов или из-за коллизий хеш функций.**

## Какая асимптотическая сложность фильтра Блума?

Производительность фильтра Блума зависит от используемых хеш-функций. Чем быстрее вычисляется хеш-функция, тем быстрее отрабатывает каждая операция над фильтром Блума.

### Временная сложность

|                                  |                        |
| -------------------------------- | ---------------------- |
| Операция                         | Временная сложность    |
| добавление элемента              | _O(k)_ или _константа_ |
| проверка принадлежности элемента | _O(k)_ или _константа_ |
Где _k_ количество хеш-функций.

Временная сложность фильтра Блума не зависит от количества элементов уже добавленных в фильтр. Все _k_ проверок независимы и могут быть выполнены параллельно.

### Пространственная сложность

Несмотря на количество находящихся в фильтре Блума элементов, фильтр требуется постоянное число битов, используя под каждый элемент несколько битов. Фильтр Блума не хранит значения добавляемых элементов, а значит имеет **константную сложность  O(1)**.

## Преимущества фильтра Блума

Преимуществами фильтра Блума являются:

- константная временная сложность;

- константная пространственная сложность;

- операции могут выполняться параллельно(на мой взгляд спорно?);

- нет ложноотрицательных срабатываний;

- обеспечивает конфиденциальность, так как не хранит значения элементов;

- возможность побитового объединения или побитового пересечения двух фильтров Блума одинаковой размерности, использующих одинаковые хеш-функции _(пер.: добавлено из комментариев к статье)_.

## Недостатки фильтра Блума

Недостатки фильтра Блума следующие:

- не поддерживает операцию удаления;

- ложноположительные срабатывания нельзя устранить в ноль;

- необходимость произвольного доступа к битам массива, индикаторы которых генерируются случайным образом хеш-функциями.


**Удаление элемента из фильтра Блума не поддерживается, так как нет возможности идентифицировать какие биты должны быть удалены. В фильтре Блума могут находится другие элементы использующие те же биты, и их очистка может привести в ложноотрицательным ошибкам.**

### Пример использования:

Фильтры Блума полезны в высоконагруженных системах для предотвращения дорогостоящих операций с дисками. Например, сервис выполняется поиск элемента в большой таблице на диске, что может привести к деградации пропускной способности сервиса. Фильтр Блума может предварительно обрабатывать поиски и отсекать ненужные операции с диском, за исключением случаев ложноположительных срабатываний. Фильтр Блума может быть применен в следующих случаях:

- сокращение обращений к диску для не существующих в базе ключей;

- определять получен ли идентификатор пользователя;

- фильтрация ранее показанных публикаций для рекомендательных движков;

- проверка слов на наличие орфографических ошибок и ненормативной лексики в [спеллчекерах](https://systemdesign.one/system-design-pastebin/#write-path);

- идентификация опасных url, заблокированных IP-адресов и мошеннических транзакций;

- хранилища, использующие журнально-структурированное дерево со слиянием ([LSM-дерево](https://ru.wikipedia.org/wiki/LSM-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)), такие как [Cassandra](https://cassandra.apache.org), используют фильтр Блума для проверки существования ключа в SSTable;;

- [MapReduce](https://ru.wikipedia.org/wiki/MapReduce) использует фильтр Блума для эффективной обработки больших наборов данных.

## Модификации фильтра Блума

### Фильтр Блума с подсчетом

![[Pasted image 20240808120149.png]]

Фильтр Блума с подсчетом включает массив счетчиков для каждого бита. Массив счетчиков инициализируется нулями. Счетчики для связанных битов увеличиваются на единицу при добавлении в фильтр Блума с подсчетом. Проверка принадлежности элемента фильтру Блума работает как в базовом фильтре. **Фильтр Блума с подсчетом поддерживает операцию удаления элемента из фильтра**. Операции выполняемые для удаления элемента из фильтра Блума с подсчетом:

1. Для элемента вычисляется _k_ хеш-функций
 
2. Полученные хеши делятся по модулю на _n_ (по длине массива битов), чтобы получить _k_ значений идентифицирующих позиции битов массива фильтра Блума

3.  Счетчики полученных позиций битов уменьшаются на единицу

4. Соответствующие биты устанавливаются в ноль, если счетчик после вычитания получает значение равное нулю

Фильтр Блума с подсчетом занимает больше памяти по сравнению с классическим, так как требуется хранить значения счетчиков, даже если большая часть значений будет равна нулю. Поэтому важно оценить насколько большими могут быть значения счетчиков и как их размер зависит от длины фильтра _n_ и количества хеш-функций _k_.

### Масштабируемый фильтр Блума

![[Pasted image 20240808120227.png]]

Фильтр Блума невозможно изменить после его насыщения элементами, так как невозможно определить какие элементы добавлены в фильтр. При этом фильтры Блума могут объединяться для масштабируемости. Как только фильтр блума наполняется элементами, новый фильтр большей емкости может быть добавлен поверх текущего фильтра. Запрос на принадлежность элемента фильтру Блума требует проверки в каждом фильтре. Дополнительно, при добавлении нового элемента требуется проверка наличия элемент в каждом нижележащем фильтре прежде, чем добавить в фильтр верхнего уровня  

### Полосатый (striped) фильтр Блума

[Striped фильтр Блума](https://github.com/iamthebot/hyperbloom) реализуется с использованием массива беззнаковых 64-битных целых чисел и разделяется на шарды для распараллеливания. Каждый шард содержит свой мьютекс, обеспечивающий повышенную пропускную способность добавления и поиска. Единственное имеющееся ограничение фильтра заключается в том, что размер фильтра Блума должен быть кратен количеству шардов.

### Другие вариации фильтра Блума

Существуют другие вариации фильтра Блума и структуры данных похожие по функциональности на фильтр Блума. Например _(пер.: большая часть примеров добавлена при переводе)_:

- [Стабильный фильтр Блума](https://github.com/tylertreat/BoomFilters?tab=readme-ov-file#stable-bloom-filter) (stable Bloom filter)
- [Quotient filter](https://systemdesign.one/quotient-filter-explained/)
- [Кукушкин фильтр](https://github.com/tylertreat/BoomFilters?tab=readme-ov-file#cuckoo-filter) (cuckoo filter)
- [Обратный фильтр Блума](https://github.com/tylertreat/BoomFilters?tab=readme-ov-file#inverse-bloom-filter) (inverse Bloom filter)
- [Count-Min Sketch](https://github.com/tylertreat/BoomFilters?tab=readme-ov-file#count-min-sketch)
- [Top-K](https://github.com/tylertreat/BoomFilters?tab=readme-ov-file#top-k)
- [HyperLogLog](https://github.com/tylertreat/BoomFilters?tab=readme-ov-file#hyperloglog)
- [MinHash](https://github.com/tylertreat/BoomFilters?tab=readme-ov-file#minhash)