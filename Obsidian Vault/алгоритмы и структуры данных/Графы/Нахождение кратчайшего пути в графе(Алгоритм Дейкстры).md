Алгоритм Дейкстры гарантирует нахождение кратчайших путей от начальной вершины до всех остальных вершин в графе с неотрицательными весами ребер. Обновление расстояний происходит путем вычисления новых расстояний до соседних вершин и сравнения их с текущими значениями. Если найден более короткий путь, расстояние обновляется, и вершина добавляется в очередь с приоритетами для дальнейшей обработки.
### Алгоритм Дейкстры: Основные шаги

1. **Инициализация:**
    * Создаем пустую очередь с приоритетами (кучу).
    * Начальная вершина `A` имеет вес `A.w = 0`.
    * Для всех остальных вершин устанавливаем вес равным бесконечности (или очень большому числу), чтобы обозначить, что путь до них еще не найден.
    * Добавляем начальную вершину `A` в очередь с приоритетами с весом 0.

2. **Основной цикл:**
    * Пока очередь с приоритетами не пуста:
        * Извлекаем вершину `current` с наименьшим текущим весом из очереди.
        * Для каждой соседней вершины `next_vertex` обновляем ее вес по формуле: `next_vertex.w = min(next_vertex.w, current.w + next_vertex.w))`.
        * Если вес соседней вершины обновляется, добавляем ее в очередь с приоритетами.

3. **Завершение:**
    * Когда очередь с приоритетами становится пустой, все вершины будут иметь минимальные веса, соответствующие кратчайшим путям от начальной вершины.

### Пример реализации на псевдокоде:

```python
import heapq

def dijkstra(graph, start_vertex):
    # Инициализация
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start_vertex] = 0
    
    priority_queue = [(0, start_vertex)]
    
    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)
        
        # Если текущее расстояние больше уже найденного, пропускаем эту вершину
        if current_distance > distances[current_vertex]:
            continue
        
        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            
            # Если найден более короткий путь, обновляем расстояние
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                # Добавляем соседнюю вершину в очередь с приоритетами 
                # с новым расстоянием
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances

# Пример графа в виде словаря смежности
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}

# Начальная вершина
start_vertex = 'A'

# Вызов алгоритма Дейкстры
shortest_distances = dijkstra(graph, start_vertex)

# Вывод результатов
print("Кратчайшие расстояния от вершины", start_vertex, "до всех остальных вершин:")
for vertex, distance in shortest_distances.items():
    print(f"Вершина: {vertex}, Расстояние: {distance}")
```

