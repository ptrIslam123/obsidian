Ethernet-адаптер (сетевой контроллер) — это устройство, обеспечивающее передачу данных между компьютером и сетью. Он состоит из нескольких ключевых блоков, каждый из которых выполняет свою функцию.  

---

## **1. MAC (Media Access Control) — Контроллер доступа к среде**  

**Media Access Control (MAC)** — это аппаратный модуль сетевого адаптера (NIC), отвечающий за **управление доступом к среде передачи данных** (например, Ethernet) и **обработку кадров (фреймов) на уровне L2 (канальный уровень)**.  
#### **1. Основные функции MAC-уровня**
MAC-модуль в NIC выполняет следующие задачи:
1. **Формирование и разбор Ethernet-кадров**:
   - Добавление/удаление заголовков (MAC-адреса отправителя/получателя, тип протокола, CRC).
   - Пример фрейма:
     ```
     | MAC Destination | MAC Source | EtherType | Payload (IP-пакет) | CRC |
     ```
2. **Контроль доступа к среде**:
   - Реализация алгоритмов **CSMA/CD** (для полудуплексного Ethernet) или **паузы** (flow control).
3. **Фильтрация трафика**:
   - Приём только кадров с нужным **MAC-адресом** или широковещательных (broadcast/multicast).
4. **Управление очередями**:
   - Обработка RX/TX-очередей (включая приоритезацию через **VLAN Tags** или **IEEE 802.1p**).
#### **2. Где находится MAC в сетевом адаптере?**
MAC — это **часть чипа сетевой карты** (интегрирован в ASIC или FPGA). В современных NIC (например, Intel X710 или Mellanox ConnectX-6) MAC работает совместно с другими блоками:

```
[CPU] <-PCIe-> [NIC Controller] <-(DMA)-> [MAC] <--> [PHY] <--> [Сетевой кабель]
```
- **PHY (Physical Layer)** — модуль, работающий с электрическими/оптическими сигналами (например, преобразует биты в импульсы для витой пары).
- **MAC + PHY** вместе образуют **Ethernet-контроллер**.
#### **3. Ключевые регистры MAC (программируемые)**
MAC-модуль настраивается через **PCI-регистры** или **специфичные порты NIC**. Пример для Intel 82599:

| **Регистр**                   | **Описание**                                         |
| ----------------------------- | ---------------------------------------------------- |
| `CTRL` (0x00000)              | Включение/выключение MAC, дуплексный режим           |
| `RCTL` (0x00100)              | Контроль приёма (RX)                                 |
| `TCTL` (0x00400)              | Контроль передачи (TX)                               |
| `RAL`/`RAH` (0x05400–0x0547F) | Таблица MAC-адресов (RAR — Receive Address Register) |
| `FCTRL` (0x05080)             | Фильтрация (broadcast, promiscuous mode)             |

#### **5. Как MAC взаимодействует с DMA?**
1. **Приём (RX)**:
   - MAC получает кадр из PHY, проверяет CRC.
   - Если кадр валиден, MAC копирует его в **RX-буфер** (через DMA) и обновляет дескриптор.
2. **Передача (TX)**:
   - CPU заполняет TX-буфер данными.
   - MAC забирает данные через DMA и отправляет в сеть.

---

## **2. PHY (Physical Layer Transceiver) — Физический приёмопередатчик**  
**PHY** — это аппаратный модуль сетевого адаптера (NIC), который отвечает за **преобразование цифровых данных в аналоговые сигналы** (и наоборот) для передачи по физической среде (медный кабель, оптоволокно). Работает на **уровне L1 (физический)** модели OSI.  
#### **1. Основные функции PHY**
| **Функция**                             | **Описание**                                                                    |
| --------------------------------------- | ------------------------------------------------------------------------------- |
| **Кодирование/декодирование**           | Преобразует биты в электрические/оптические сигналы (NRZ, PAM4, MLT-3 и др.).   |
| **Синхронизация**                       | Генерация тактового сигнала (clock recovery) для правильного распознавания бит. |
| **Автосогласование (Auto-Negotiation)** | Автоматический выбор скорости (10/100/1000 Мбит/с) и дуплексного режима.        |
| **Выравнивание (Equalization)**         | Компенсация искажений сигнала в длинных кабелях.                                |
| **Изоляция гальваническая**             | Защита от помех и перепадов напряжения (через трансформаторы).                  |

#### **2. Где находится PHY в сетевом адаптере?**
PHY — это **отдельный чип** или часть SoC (System on Chip) в NIC. Расположение в схеме:
```
[CPU] ↔ [Контроллер MAC] ↔ [PHY] ↔ [Трансформатор] ↔ [Разъём RJ45/SFP+]
```
- В **высокоскоростных адаптерах** (10G+) PHY может быть интегрирован в один чип с MAC (например, Intel X550).
- В **бюджетных NIC** (Realtek RTL8111) PHY — это отдельная микросхема.

#### **3. Как PHY взаимодействует с MAC?**
Через стандартные интерфейсы:

| **Интерфейс**                                   | **Описание**                                    | **Где используется**      |
| ----------------------------------------------- | ----------------------------------------------- | ------------------------- |
| **MII (Media Independent Interface)**           | 4-битная шина, до 100 Мбит/с.                   | Старые Ethernet-адаптеры. |
| **GMII (Gigabit MII)**                          | 8-битная шина, до 1 Гбит/с.                     | Гигабитные NIC.           |
| **SGMII (Serial GMII)**                         | Последовательная версия GMII (меньше проводов). | 1G/2.5G PHY.              |
| **XAUI (10 Gigabit Attachment Unit Interface)** | 4 линии по 3.125 Гбит/с (10G Ethernet).         | 10G SFP+ адаптеры.        |
| **USXGMII (Universal Serial 10G MII)**          | Поддержка 1G/2.5G/5G/10G на одной линии.        | Мультигигабитные PHY.     |

---

## **3. DMA (Direct Memory Access) — Прямой доступ к памяти**  
**Функции:**  
- Позволяет передавать данные **между MAC и оперативной памятью** без участия CPU.  
- Использует **кольцевые буферы (TX/RX Descriptor Rings)** для эффективного обмена.  
- Генерирует прерывания (IRQ) при завершении передачи/приёма.  

**Как работает:**  
1. Драйвер выделяет буферы в ОЗУ.  
2. MAC записывает принятые пакеты в **RX-буфер** через DMA.  
3. Для передачи CPU помещает данные в **TX-буфер**, MAC забирает их через DMA.  

---

## **4. FIFO-буферы (First In, First Out)**  
- **TX FIFO** — буфер для данных, готовых к передаче.  
- **RX FIFO** — буфер для принятых данных перед отправкой в ОЗУ.  
- Помогают сгладить задержки при работе с DMA.  

---

## **5. Clock Control Unit (CCU) — Блок управления тактовыми сигналами**  
- Генерирует тактовые частоты для MAC и PHY.  
- Включает/выключает тактирование для энергосбережения.  

---

## **6. Системный интерфейс (Host Interface)**  
Способ подключения Ethernet-контроллера к системе:  
- **PCI/PCIe** — для дискретных сетевых карт.  
- **USB** — для внешних адаптеров.  
- **Встроенный в SoC** (например, на чипах ARM, x86).  

---

## **7. Дополнительные компоненты (в зависимости от модели)**  
- **EEPROM/Flash** — хранит MAC-адрес и настройки.  
- **LED-контроллер** — управляет индикаторами (Link, Activity).  
- **Аппаратное шифрование** (TLS, IPsec).  
- **Wake-on-LAN (WoL)** — пробуждение ПК по сети.  

# **Полный путь сетевого фрейма от провода до ядерного сетевого стека Linux**

## **1. Физический уровень (PHY)**
**Что происходит:**
1. **Приём сигнала**:
   - Электрический/оптический сигнал поступает в **PHY-трансивер** через разъём (RJ45/SFP+).
   - PHY выполняет:
     - Аналого-цифровое преобразование (для медных кабелей).
     - Тактовую синхронизацию (clock recovery).
     - Автосогласование скорости/дуплекса (Auto-Negotiation).

2. **Декодирование**:
   - PHY преобразует сигнал в битовый поток, применяя:
     - **Кодирование** (NRZ, PAM4 для 100G).
     - **Выравнивание** (компенсация искажений в кабеле).

3. **Передача в MAC**:
   - Данные передаются через интерфейс **MII/GMII/RGMII** (для 1G/10G) или **XAUI** (для 10G+).

## **2. Канальный уровень (MAC)**
**Что происходит:**
1. **Обработка фрейма**:
   - MAC проверяет:
     - **CRC** (отбрасывает фрейм при ошибке).
     - **MAC-адрес** (если не совпадает с адресом NIC — фрейм игнорируется, если не включён promiscuous mode).

2. **Фильтрация**:
   - Аппаратная фильтрация по:
     - **Unicast/Multicast/Broadcast**.
     - **VLAN** (если включена VLAN offload).

3. **DMA и буферизация**:
   - MAC копирует фрейм в **RX-кольцо (Descriptor Ring)** в памяти через DMA.
   - Используется **Ring Buffer** (циклический буфер дескрипторов):
     ```c
     struct rx_desc {
         uint64_t addr;  // Физический адрес буфера
         uint16_t length;
         uint16_t status; // Флаг DD (Descriptor Done)
     };
     ```

---

## **3. Аппаратное ускорение (опционально)**
**Возможные оптимизации:**
1. **RSS (Receive Side Scaling)**:
   - NIC вычисляет хеш от IP/порта и выбирает RX-очередь для балансировки по CPU-ядрам.
   - Регистр **RETA (Redirection Table)** управляет распределением.

2. **LRO (Large Receive Offload)**:
   - Объединение TCP-пакетов в один большой буфер перед передачей в ОС.

3. **VXLAN/Geneve Offload**:
   - Деконкапсуляция туннельных пакетов на уровне NIC.



#### **Как NIC распределяет трафик по RX-очередям и CPU-ядрам (RSS, RPS, XPS)**

При высокой нагрузке (например, 10G+ трафик) **одного CPU-ядра недостаточно** для обработки всех пакетов. Решения:
- **RSS (Receive Side Scaling)** — аппаратная балансировка на уровне NIC.
- **RPS (Receive Packet Steering)** — программная балансировка в ядре Linux.
- **XPS (Transmit Packet Steering)** — балансировка исходящего трафика.


### **Как работает RSS (аппаратная балансировка)**
##### **Шаг 1: Вычисление хеша**
NIC вычисляет **хеш-сумму** для каждого пакета на основе:
- **IP-адресов** (источник/назначение).
- **Портов** (для TCP/UDP).
- **Протокола** (IPv4/IPv6).

Пример хеш-функции (Toeplitz hash):
```c
hash = (src_ip, dst_ip, src_port, dst_port, protocol) % число_очередей;
```

##### **Шаг 2: Выбор RX-очереди**
Хеш определяет, в какую **RX-очередь** NIC положит пакет:
- Каждая RX-очередь привязана к **отдельному IRQ**.
- Каждый IRQ обрабатывается **определённым CPU-ядром**.

Пример для 4-ядерного CPU:
```
RX Queue 0 → IRQ 50 → CPU0
RX Queue 1 → IRQ 51 → CPU1
RX Queue 2 → IRQ 52 → CPU2
RX Queue 3 → IRQ 53 → CPU3
```

##### **Шаг 3: Настройка RETA (Redirection Table)**
NIC использует **таблицу перенаправления (RETA)**, чтобы распределить хеши по очередям.  
Пример для 8-хэшных значений и 4 очередей:
```
RETA[0] = Queue 0
RETA[1] = Queue 1
RETA[2] = Queue 2
RETA[3] = Queue 3
RETA[4] = Queue 0  // Циклическое распределение
RETA[5] = Queue 1
RETA[6] = Queue 2
RETA[7] = Queue 3
```

**Как изменить RETA:**
```bash
ethtool -X eth0 equal 4     # Равномерно по 4 очередям
ethtool -X eth0 weight 6,2  # 75% трафика в Queue0, 25% в Queue1
```

## **Как CPU обрабатывает RX-очереди?**
##### **Привязка IRQ к ядрам**
Каждая RX-очередь генерирует **прерывание (IRQ)**, которое обрабатывается определённым ядром.  

**Просмотр текущей привязки:**
```bash
cat /proc/interrupts | grep eth0
```
Вывод:
```
50: 100000 0 0 0  IRQ-PCI-MSI-edge  eth0-rx-0  # CPU0
51: 0 50000 0 0   IRQ-PCI-MSI-edge  eth0-rx-1  # CPU1
```

**Изменение привязки IRQ:**
```bash
echo 2 > /proc/irq/50/smp_affinity  # Привязать IRQ 50 к CPU1 (маска 0x2)
```

---

## **RPS (Receive Packet Steering)**
Если NIC **не поддерживает RSS**, Linux использует **программную балансировку RPS**:
1. Пакет принимается **одним CPU** (например, CPU0).
2. Ядро вычисляет хеш (аналогично RSS) и выбирает целевое ядро.
3. Пакет передаётся в очередь **softirq** другого ядра.

**Настройка RPS:**
```bash
echo f > /sys/class/net/eth0/queues/rx-0/rps_cpus  # Распределять по CPU0-3
```

---

## **4. Прерывание или Polling**
**Варианты работы:**
1. **Режим прерываний (IRQ)**:
   - NIC генерирует прерывание по завершении DMA.
   - Обработчик прерывания (`ixgbe_irq_handler`) планирует NAPI.

2. **Режим polling (NAPI)**:
   - Ядро периодически опрашивает NIC через `napi_schedule()`.
   - Используется для высокоскоростных интерфейсов (10G+).

---

## **5. Передача в ядерный сетевой стек**
**Шаги:**
1. **Создание `sk_buff`**:
   - Драйвер (например, `ixgbe`) создаёт структуру `sk_buff` — контейнер для пакета в ядре.
   - Данные копируются из DMA-буфера в `sk_buff` (или используется **Zero-Copy**, если поддерживается).

2. **Метод `netif_receive_skb()`**:
   - Пакет передаётся в:
     - **Сетевой стек** (если адрес совпадает).
     - **Мост (bridge)** или **OVS** (если интерфейс в мостовом режиме).

3. **Обработка в ядре**:
   - **Уровень 2 (L2)**:
     - Проверка **EtherType** (IPv4/IPv6/ARP).
     - Удаление Ethernet-заголовка.
   - **Уровень 3 (L3)**:
     - Маршрутизация через `ip_rcv()`.
     - Проверка **iptables/nftables** (HOOK `NF_INET_PRE_ROUTING`).

4. **Доставка в сокет**:
   - Если пакет для локального хоста — передача в транспортный уровень (TCP/UDP).
   - Копирование данных в userspace через системный вызов `recv()`.

---


## **6. Визуализация пути пакета**
```
[Кабель] → [PHY] → [MAC] → [DMA] → [RX Ring] → [IRQ/NAPI] → [sk_buff] → 
[L2 (eth_type)] → [L3 (ip_rcv)] → [Netfilter] → [Сокет]
```

---

## **Оптимизации**
- **XDP (eXpress Data Path)**: Обработка пакета до создания `sk_buff` (например, для DDoS-фильтрации).
- **DPDK**: Полный обход ядра (пакеты сразу в userspace).
- **AF_XDP**: Прямая передача из NIC в userspace через сокеты.
