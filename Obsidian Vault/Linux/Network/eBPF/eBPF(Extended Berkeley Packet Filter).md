eBPF — это революционная технология ядра Linux, позволяющая **безопасно выполнять пользовательский код в пространстве ядра** без его модификации. Изначально созданный для фильтрации сетевых пакетов (cBPF), eBPF эволюционировал в **универсальную платформу** для мониторинга, сетевой обработки, безопасности и многого другого.  

---

# **Ключевые возможности eBPF**  

### **Безопасное выполнение кода в ядре**  
Отличный вопрос! **eBPF считается безопасной технологией для выполнения кода в ядре**, потому что она была спроектирована с самого начала с акцентом на **безопасность, изоляцию и надёжность**. Ниже я объясню **основные механизмы**, которые обеспечивают эту безопасность.

### 1. **Проверка программы (Verifier)**

Перед тем как загрузить программу в ядро, eBPF-верификатор проверяет её:
#### Что делает верификатор:
- **Доказывает, что программа завершится** (не содержит бесконечных циклов).
- Проверяет, чтобы все пути исполнения были конечными.
- Убеждается, что нет неинициализированных данных или неопределённого поведения.
- Проверяет, что доступ к памяти корректен (только через безопасные вызовы `bpf_*` helper-функции).
- Убеждается, что структуры данных соответствуют ожидаемому формату (например, заголовки сетевых пакетов).

Это гарантирует, что даже при наличии бага в пользовательской программе **она не может "сломать" ядро**.
### 2. **Изоляция от ядра**

eBPF-программы работают в **ограниченном окружении** внутри ядра:

- Они **не имеют прямого доступа к произвольной памяти ядра**.
- Обмен данными между ядром и пользовательским пространством осуществляется через **eBPF-карты (maps)** — заранее определённые структуры данных.
- Программы могут использовать только ограниченное число регистров и стек (обычно до 512 байт).

Это обеспечивает **сильную песочницу** вокруг eBPF-кода.
### 3. **Helper-функциции**

Вместо того чтобы разрешить произвольный доступ к ядру, eBPF предоставляет набор **встроенных функций (helper functions)**, таких как:

- `bpf_map_lookup_elem()` — поиск элемента в карте
- `bpf_get_current_uid_gid()` — получить UID текущего пользователя
- `bpf_ktime_get_ns()` — получить текущее время
- `bpf_skb_store_bytes()` — изменить данные сетевого пакета и т.д.

Эти функции **абстрагируют низкоуровневый доступ** к ядру и защищают его от случайного или злонамеренного повреждения.
### 4. **Just-In-Time (JIT) компиляция**

Ядро может скомпилировать eBPF-байткод в машинный код для ускорения работы. Но даже в этом случае:
- JIT-компилятор также работает под контролем верификатора.
- Генерируемый код **не имеет привилегий**, необходимых для изменения ядра.
- На многих системах JIT можно отключить, и тогда программы будут выполняться интерпретатором — медленнее, но безопаснее.
### 5. **Привилегии и контроль доступа**

Загрузка eBPF-программ обычно требует повышенных привилегий (`CAP_SYS_ADMIN`), хотя это можно настраивать через **seccomp**, **AppArmor**, **SELinux** и другие механизмы безопасности.

Также есть проекты, такие как **libbpf CO-RE** и **BTF**, которые позволяют более гибко и безопасно взаимодействовать с внутренними структурами ядра без хардкода.


# **Гибкие точки привязки (hooks)**  

**eBPF — это в первую очередь событийно-ориентированная (event-driven) технология**, но не **только** такая

## Основной принцип: eBPF реагирует на события

Да, **основной способ работы с eBPF — это привязка программ к определённым событиям в системе**. Например:

| Источник события | Примеры |
|------------------|---------|
| Сетевые пакеты | Приход нового пакета (`XDP`, `TC`) |
| Системные вызовы | Вызов `execve()`, `open()`, `read()` и т.д. |
| Трассировка ядра | `tracepoint`, `kprobe`, `uprobe` |
| Таймеры | Можно запускать программы по таймеру через `perf` или `BPF_MAP_TYPE_QUEUE` |
| События LSM | Для политик безопасности |

Каждая eBPF-программа обычно **выполняется в ответ на какое-то событие**. Это делает eBPF идеально подходящей для:

- Мониторинга
- Трассировки
- Фильтрации сетевых пакетов
- Политик безопасности
- Обработки событий в реальном времени

# **Общая память между ядром и пользовательским пространством**  

- **eBPF Maps** — ключ-значение хранилища (хеш-таблицы, массивы, кольцевые буферы).  
- **Perf Events** — передача данных в пользовательское пространство (например, для мониторинга).  

### **eBPF Maps

eBPF Maps — это **обобщенные структуры данных**, которые позволяют передавать информацию между:  
- **eBPF-программами** (работающими в ядре),  
- **пользовательскими приложениями** (через syscall или библиотеки вроде `libbpf`),  
- **разными экземплярами eBPF-программ**.  

Карты хранят данные в виде **ключ-значение** и поддерживают множество типов: от простых хеш-таблиц до сложных структур, таких как кольцевые буферы.  

### **1. Простые Key-Value хранилища**  
| Тип карты                     | Описание                                                                 |
|-------------------------------|--------------------------------------------------------------------------|
| `BPF_MAP_TYPE_HASH`           | Классическая хеш-таблица (динамический размер).                         |
| `BPF_MAP_TYPE_ARRAY`          | Массив с фиксированным размером (ключ — индекс `u32`).                  |
| `BPF_MAP_TYPE_PERCPU_HASH`    | Хеш-таблица с отдельными значениями для каждого CPU (для lock-free доступа). |
| `BPF_MAP_TYPE_LRU_HASH`       | Хеш-таблица с вытеснением редко используемых элементов (LRU-кеш).       |

### **2. Специализированные структуры**  
| Тип карты                     | Применение                                                              |
|-------------------------------|--------------------------------------------------------------------------|
| `BPF_MAP_TYPE_PERF_EVENT_ARRAY` | Передача событий в пользовательское пространство через `perf_buffer`.  |
| `BPF_MAP_TYPE_RINGBUF`        | Кольцевой буфер (односторонняя передача данных с минимальными накладными расходами). |
| `BPF_MAP_TYPE_QUEUE`          | FIFO-очередь (добавление через `bpf_map_push_elem`, чтение из userspace). |
| `BPF_MAP_TYPE_STACK`          | LIFO-стек (аналогично очереди, но порядок обратный).                    |

### **3. Карты для работы с программами**  
| Тип карты                     | Описание                                                                 |
|-------------------------------|--------------------------------------------------------------------------|
| `BPF_MAP_TYPE_PROG_ARRAY`     | Массив файловых дескрипторов eBPF-программ (для динамического переключения логики). |
| `BPF_MAP_TYPE_DEVMAP`         | Перенаправление пакетов на сетевые интерфейсы (используется в XDP).     |

### **4. Экзотические и экспериментальные**  
| Тип карты                     | Назначение                                                              |
|-------------------------------|--------------------------------------------------------------------------|
| `BPF_MAP_TYPE_BLOOM_FILTER`   | Фильтр Блума для вероятностной проверки наличия элемента.               |
| `BPF_MAP_TYPE_ARENA`          | Общая память для взаимодействия между программами (экспериментально).  |

## **Ограничения и подводные камни**  
- **Размер ключа/значения** фиксирован при создании карты.  
- **Нет встроенных блокировок** (используйте `PERCPU`-карты для lock-free доступа).  
- **Максимальный размер** зависит от типа карты (например, `RINGBUF` ограничен памятью).  
- **Производительность**: `HASH` быстрее `ARRAY`, но требует больше памяти.  

### **Вызов вспомогательных функций (helpers)**  
- **Доступ к структурам ядра** (`bpf_probe_read`).  
- **Манипуляции с сетевыми пакетами** (перенаправление, модификация).  
- **Работа с системными вызовами** (например, `bpf_sysctl_get_name`).  

### **Динамическая загрузка и обновление**  
- Программы можно загружать **без перезагрузки ядра**.  
- Поддержка **BTF (BPF Type Format)** для совместимости между версиями ядра.  

Более углубленное и подробное руководство по [[BPF_MAP_TYPE_HASH]]

---

# **Где применяется eBPF?**  

### **1. Сетевые технологии**  
- **XDP (eXpress Data Path)** – обработка пакетов **на уровне драйвера NIC** (до 10M+ pps).  
- **Cilium** – замена `iptables` в Kubernetes (сервис-меш, балансировка нагрузки).  
- **DDOS-защита** (отбрасывание пакетов до попадания в стек ядра).  
- **Мониторинг трафика** (например, `katran` от Facebook).  

### **2. Наблюдаемость и трассировка**  
- **Профилирование CPU/памяти** (`bpftrace`, `BCC`).  
- **Трассировка системных вызовов** (`tracepoint`, `kprobe`, `uprobe`).  
- **Анализ задержек** (например, `biolatency` из BCC).  

### **3. Безопасность**  
- **Sandboxing** (ограничение системных вызовов, например, `seccomp` на стероидах).  
- **Обнаружение аномалий** (`Falco` для детектирования взломов).  
- **Анти-руткиты** (мониторинг модификаций ядра).  

### **4. Хранение и обработка данных**  
- **Кольцевые буферы (ringbuf)** – эффективная передача событий.  
- **LRU-кеши** – ускорение доступа к данным.  

### **5. Ускорение работы ядра**  
- **Оптимизация файловых систем** (например, `eBPF + EXT4`).  
- **Ускорение сетевого стека** (например, `TCP-BPF` для оптимизации соединений).  

---

## **Инструменты и экосистема eBPF**  

| Категория        | Инструменты                                                  |
| ---------------- | ------------------------------------------------------------ |
| **Трассировка**  | `bpftrace`, `BCC` (BPF Compiler Collection), `kubectl-trace` |
| **Сеть**         | `Cilium`, `katran`, `XDP`-инструменты (например, `AF_XDP`)   |
| **Безопасность** | `Falco`, `Tracee`, `Tetragon`                                |
| **Мониторинг**   | `Pixie`, `Hubble`, `parca`                                   |
| **Разработка**   | `libbpf`, `bpftool`, `CO-RE` (Compile Once – Run Everywhere) |
|                  |                                                              |

---

### Inspecting The Flows

![[linux_kernel_network_stack.png]]
## **Ограничения eBPF**  
- **Нет бесконечных циклов** (верификатор требует ограниченного времени выполнения).  
- **Ограниченный доступ к памяти** (только через безопасные helpers).  
- **Требуются права** (`CAP_BPF` или root).  
- **Зависимость от версии ядра** (не все фичи есть в старых ядрах).  

# Компиляция eBPF программ

# Загрузка в ядро eBPF программ
[[BCC(BPF Compiler Collection)]]
[[libbpf]]

# Полезные ресурсы
https://github.com/xdp-project/bpf-examples
https://docs.kernel.org/bpf/index.html
https://docs.ebpf.io/
https://docs.ebpf.io/linux/helper-function/
https://thegraynode.io/posts/
https://eunomia.dev/tutorials/