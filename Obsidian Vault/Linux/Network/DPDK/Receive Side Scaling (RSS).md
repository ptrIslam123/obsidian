**RSS (Receive Side Scaling)** — это аппаратный механизм, реализованный в сетевой карте (NIC), позволяющий **распределять входящие пакеты по нескольким RX-очередям** , чтобы эффективно использовать **многопроцессорную обработку** .

Это помогает:
- Увеличить пропускную способность
- Снизить задержки
- Лучше использовать многоядерные процессоры
---

### **1. Поступление пакета на сетевую карту (NIC)**
- **Физический уровень**: Пакет принимается через Ethernet-интерфейс, проходит через PHY-слой (модуляция/демодуляция сигнала), затем попадает в буфер NIC.
- **Проверка CRC**: NIC проверяет контрольную сумму кадра (FCS). При ошибке пакет отбрасывается.
- **Фильтрация**: NIC определяет, предназначен ли пакет этому узлу (по MAC-адресу или VLAN-тегу).

---

### **2. Определение хеша RSS (для многопоточности)**
Сетевая карта вычисляет **хэш от определённых полей заголовка** , используя специальную функцию (обычно **Toeplitz hash** )
### Как вычисляется хэш:
- Используется **хэш-ключ (RSS key)** — секретный ключ, известный только драйверу.
- Выбираются поля из заголовков:
    - IPv4/IPv6: `src IP`, `dst IP`
    - TCP/UDP: `src port`, `dst port`
    - VLAN ID (если поддерживается)
    - Возможно другие поля, в зависимости от конфигурации

Пример ключа RSS (из `ethtool -x eth0`):
```
RSS hash key:
6d:5a:56:da:25:5b:0e:c2:41:67:25:3d:43:a3:8f:b0:d0:ca:2b:cb:ae:7b:30:b4:77:cb:2d:a3:80:30:f2:0c:6a:42:b7:3b:be:ac:01:fa
```

---
## 3. **Индексирование по таблице индирекции (Indirection Table)**

После вычисления хэша он используется как индекс в **таблице индирекции (indirection table)** 
#### **Таблица индирекции (Indirection Table)**
- Массив размером 128 или 256 элементов
- Каждый элемент указывает на номер RX-очереди (от `0` до `n-1`)
- Позволяет гибко перенаправлять пакеты в нужные очереди
#### Пример:
- Хэш = `0x12345678`
- Таблица индирекции содержит 128 записей (или 256, зависит от NIC)
- Берётся младшая часть хэша → например, `hash % 128 = 42`
- Запись в таблице `indir[42]` указывает на номер RX-очереди (например, `queue 5`)

Таким образом, пакет должен направляется в очередь `rx5`.

---

## 4. **Передача пакета в RX-очередь**

Пакет копируется в **буфер памяти** , связанный с соответствующей RX-очередью.

- Используется **DMA (Direct Memory Access)** — пакет копируется прямо в RAM без участия CPU
- В конце операции может быть вызвано **прерывание (legacy или MSI-X)** , если оно не отключено

## 5. **Обработка пакета ядром или пользовательским пространством**

В зависимости от режима работы системы:
#### A. **Ядерный стек (kernel networking stack)**
- Ядро получает пакет через NAPI (New API)
- Обрабатывается через `softirq` (`NET_RX_SOFTIRQ`)
- Передаётся дальше в протокольные стеки (IP, TCP/UDP и т.д.)
#### B. **AF_XDP / DPDK / XDP**
- Пакет направляется напрямую в пользовательское пространство
- Обрабатывается без участия ядра (zero-copy)
- Может быть обработан с помощью `testpmd`, `xdpd`, `ovs-dpdk` и т.д.


----
---
**Отображение на CPU**: В Linux это настраивается через IRQ affinity (например, `smp_affinity`). Каждой очереди соответствует свой прерывание (IRQ).




### **4. Прерывание (Interrupt) и обработка пакета**
- **Прерывание MSI-X**: Современные NIC используют MSI-X (Message Signaled Interrupts), чтобы уведомить CPU о новом пакете в конкретной очереди.
- **SoftIRQ**: В Linux обработка пакета происходит в контексте SoftIRQ (сетевой подсистемы `NET_RX`). Задача:
  - Копирование пакета из буфера NIC в память ОС (DMA).
  - Разбор заголовков (Ethernet → IP → TCP/UDP).
  - Передача в стек протоколов (например, `tcp_v4_rcv()` для TCP/IPv4).

---

### **5. Настройка RSS в ОС**
В Linux параметры RSS можно просмотреть и изменить через `ethtool`:
```bash
# Показать число очередей
ethtool -l eth0

# Показать используемые поля для хеширования
ethtool -n eth0 rx-flow-hash tcp4

# Изменить ключ RSS
ethtool -X eth0 hkey 6d:5a:56:da:25:5b:0e:c2:41:67:25:3d...

# вывести статистику очередей RX/TX у NIC
sudo ethtool -S enp59s0f0np0 | grep -E '([rt]x[0-9]+_xsk_)'
```

Эти метрики относятся к статистике работы сетевого интерфейса (`rx0`) в режиме **XDP (eXpress Data Path)** с использованием **AF_XDP (Address Family XDP)** — высокопроизводительного пути обработки пакетов в ядре Linux.  

### **Объяснение метрик:**
1. **`rx0_xsk_packets`** – Общее количество принятых пакетов через XSK (XDP socket).  
2. **`rx0_xsk_bytes`** – Общий объём данных (в байтах), полученных через XSK.  
3. **`rx0_xsk_csum_complete`** – Количество пакетов, для которых аппаратно вычислена контрольная сумма (checksum).  
4. **`rx0_xsk_csum_unnecessary`** – Количество пакетов, для которых проверка контрольной суммы не требовалась (например, локальный трафик).  
5. **`rx0_xsk_csum_unnecessary_inner`** – То же, что и `csum_unnecessary`, но для внутренних заголовков (используется в инкапсулированных пакетах, например, VXLAN/GRE).  
6. **`rx0_xsk_csum_none`** – Количество пакетов без проверки контрольной суммы (например, UDP без checksum).  
7. **`rx0_xsk_ecn_mark`** – Количество пакетов с маркировкой ECN (Explicit Congestion Notification).  
8. **`rx0_xsk_removed_vlan_packets`** – Количество пакетов, из которых был удалён VLAN-тег.  
9. **`rx0_xsk_xdp_drop`** – Количество пакетов, отброшенных XDP-программой (например, из-за фильтрации).  
10. **`rx0_xsk_xdp_redirect`** – Количество пакетов, перенаправленных XDP (например, в другой интерфейс или userspace через AF_XDP).  
11. **`rx0_xsk_wqe_err`** – Ошибки Work Queue Entries (WQE) в NIC (например, переполнение очереди).  
12. **`rx0_xsk_mpwqe_filler_cqes`** – Количество CQE (Completion Queue Entries) для "заполняющих" пакетов в Multi-Packet WQE (используется в некоторых NIC для оптимизации).  
13. **`rx0_xsk_mpwqe_filler_strides`** – Количество "страйдов" (strides) в Multi-Packet WQE.  
14. **`rx0_xsk_oversize_pkts_sw_drop`** – Количество слишком больших пакетов, отброшенных программно (не аппаратно).  
15. **`rx0_xsk_buff_alloc_err`** – Ошибки выделения буферов (например, нехватка памяти в UMEM).  
16. **`rx0_xsk_cqe_compress_blks`** – Количество сжатых блоков в Completion Queue (аппаратная оптимизация).  
17. **`rx0_xsk_cqe_compress_pkts`** – Количество сжатых пакетов в Completion Queue.  
18. **`rx0_xsk_congst_umr`** – Количество пакетов, отброшенных из-за перегрузки UMR (User Memory Region).  

### **Что это значит в вашем случае?**
- Очень высокое значение **`rx0_xsk_xdp_redirect`** (`3193194192`) говорит о том, что почти весь трафик перенаправляется (например, в пользовательское пространство через AF_XDP).  
- Большое значение **`rx0_xsk_xdp_drop`** (`228516882`) может указывать на агрессивную фильтрацию или ошибки в XDP-программе.  
- **`rx0_xsk_buff_alloc_err`** (`2422407`) означает, что иногда не хватает буферов для приёма пакетов (возможно, нужно увеличить размер UMEM или оптимизировать обработку).  

### **Как это используется?**
Такие метрики важны для:
- Мониторинга производительности XDP/AF_XDP.  
- Оптимизации DDoS-защиты (если XDP используется для фильтрации).  
- Анализа потерь пакетов и узких мест в сети.  


## Resources:
https://learn.microsoft.com/ru-ru/windows-hardware/drivers/network/introduction-to-receive-side-scaling